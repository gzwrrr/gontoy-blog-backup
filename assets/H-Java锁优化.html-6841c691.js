import{_ as l,Q as i,S as a,a5 as r}from"./framework-ec2af7a3.js";const t={},e=r('<h1 id="java锁优化" tabindex="-1"><a class="header-anchor" href="#java锁优化" aria-hidden="true">#</a> Java锁优化</h1><h1 id="java-主流锁体系" tabindex="-1"><a class="header-anchor" href="#java-主流锁体系" aria-hidden="true">#</a> Java 主流锁体系</h1><ul><li>乐观锁、悲观锁</li><li>读锁（共享锁）、写锁（排他锁）</li><li>自旋锁、非自旋锁</li><li>无锁、偏向锁、轻量级锁、重量级锁</li><li>分布式锁</li><li>区间锁（分段锁）</li><li>重入锁、非重入锁</li><li>公平锁、非公平锁</li></ul><p><strong>线程是否要锁住同步资源：</strong></p><ul><li>锁住：悲观锁</li><li>不锁住：乐观锁</li></ul><p><strong>锁住同步资源失败线程是否要阻塞：</strong></p><ul><li>阻塞</li><li>不阻塞： <ul><li>自旋锁</li><li>适应性自旋锁</li></ul></li></ul><p><strong>多个线程竞争同步资源的流程细节：</strong></p><ul><li>不锁住资源，多个线程只有一个能修改资源成功，其他线程会重试——无锁</li><li>同一个线程执行同步资源时自动获得资源——偏向锁</li><li>多个线程竞争同步资源时，没有获取资源的线程自旋等待锁释放——轻量级锁</li><li>多个线程竞争同步资源时，没有获取资源的线程阻塞等待唤醒——总量级锁</li></ul><p><strong>多个线程竞争锁时是否要排队：</strong></p><ul><li><p>排队：公平锁</p></li><li><p>不排队：非公平锁，先尝试插队，插队失败再排队</p></li></ul><p><strong>一个线程的多个流程能不能获取同一把锁：</strong></p><ul><li>能：可重入锁</li><li>不能：不可重入锁</li></ul><p><strong>多个线程能不能共享一把锁：</strong></p><p>能：共享锁</p><p>不能：排他锁</p><h1 id="自旋锁" tabindex="-1"><a class="header-anchor" href="#自旋锁" aria-hidden="true">#</a> 自旋锁</h1><ul><li>指当一个线程在获得锁时，如果锁已经被其他线程获取，那么该线程将循环等待</li><li>然后不断判断锁是否能被成功获取，自旋直到获取到锁后才退出循环</li></ul><p><strong>自旋锁的意义与使用场景：</strong></p><ul><li>不是用 cas 时：阻塞与唤醒线程需要操作系统切换 CPU 状态，需要消耗一定的时间</li><li>场景：同步代码块逻辑简单，执行时间很短</li></ul><p><strong>自适应自旋：</strong></p><ul><li>假定不同线程持有同一个锁对象的时间基本相当</li><li>竞争度趋于稳定，可以根据上一次自旋的时间与结果调整下一次自旋的时间</li></ul>',22),n=[e];function s(o,p){return i(),a("div",null,n)}const c=l(t,[["render",s],["__file","H-Java锁优化.html.vue"]]);export{c as default};
