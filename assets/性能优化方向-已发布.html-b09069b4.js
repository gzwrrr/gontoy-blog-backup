import{_ as r,Q as n,S as t,U as l,a4 as i,W as a,a5 as h,H as u}from"./framework-ec2af7a3.js";const o={},d=h('<h1 id="性能优化方向" tabindex="-1"><a class="header-anchor" href="#性能优化方向" aria-hidden="true">#</a> 性能优化方向</h1><h1 id="_1-索引" tabindex="-1"><a class="header-anchor" href="#_1-索引" aria-hidden="true">#</a> 1.索引</h1><p>索引是否没加？</p><p>索引是否没生效？</p><ul><li>失效原因： <ul><li>不满足最左前缀原则</li><li>范围索引列没有放到最后</li><li>使用 select *</li><li>索引列上有计算</li><li>索引列上使用了函数</li><li>字符类型没加引号</li><li>用 is null 和 is not null 没注意字段是否允许为空</li><li>like 查询的左边有 %</li><li>错误使用 or</li><li>选错索引，使用 force index 强制走某一个索引</li></ul></li><li>解决步骤： <ul><li>使用 explain 查看</li><li>按照失效可能的原因逐步排查并修改</li></ul></li></ul><br><h1 id="_2-sql-优化" tabindex="-1"><a class="header-anchor" href="#_2-sql-优化" aria-hidden="true">#</a> 2.SQL 优化</h1><ul><li>避免使用 select *</li><li>用 union all 代替 union</li><li>小表驱动大表</li><li>批量操作</li><li>多用 limit</li><li>减少 in 中包含的字段</li><li>增量查询</li><li>多用分页</li><li>用连接查询代替子查询</li><li><code>join</code> 的表尽可能少</li><li>控制索引的数量</li><li>选择合理的字段类型</li><li>提升 group by 的效率</li></ul><br><h1 id="_3-调用优化" tabindex="-1"><a class="header-anchor" href="#_3-调用优化" aria-hidden="true">#</a> 3.调用优化</h1><ul><li>同一个接口中需要调用多个服务时，可以将同步调用改成异步调用</li><li>使用 CompleteFuture</li><li>线程池改造服务调用，同时也能防止连接数过多</li><li>使用保存冗余数据的数据异构方案，但是这样可能导致数据不一致</li><li>尽量避免重复调用查询语句</li><li>尽量避免在使用乐观锁（如 CAS 自旋锁）时出现极端情况死循环</li><li>在有递归的地方设置最大递归深度避免无限递归</li><li>可以异步处理不重要的信息，如日志与站内通知</li></ul><br><h1 id="_4-事务优化-避免大事务" tabindex="-1"><a class="header-anchor" href="#_4-事务优化-避免大事务" aria-hidden="true">#</a> 4.事务优化（避免大事务）</h1><ul><li>大事务可能引发的问题： <ul><li>死锁</li><li>锁等待</li><li>回滚时间长</li><li>接口超时</li><li>并发情况下数据库连接池沾满</li><li>数据库主从延迟</li></ul></li><li>优化方向： <ul><li>减少使用 @Transaction 注解</li><li>将查询方法放到事务外</li><li>事务中避免远程调用</li><li>事务中避免一次性处理太多数据</li></ul></li></ul><br><h1 id="_5-减小锁粒度" tabindex="-1"><a class="header-anchor" href="#_5-减小锁粒度" aria-hidden="true">#</a> 5.减小锁粒度</h1><ul><li>判断是否有必要加锁，判断不出则压测看数据</li><li>减小锁的范围，一些不用考虑一致性的操作可以放到锁外</li><li>分布式版应用使用分布式锁，如 redis 分布式锁</li><li>数据库的分布式锁推荐的使用顺序：行锁 &gt; 间隙锁 &gt; 表锁</li></ul><br><h1 id="_6-分页处理" tabindex="-1"><a class="header-anchor" href="#_6-分页处理" aria-hidden="true">#</a> 6.分页处理</h1><ul><li>减小接口查询的数据量</li><li>同步查询时可以使用 guava 中 Lists.partition 方法分页</li><li>使用异步调用完成分页</li></ul><br><h1 id="_7-缓存" tabindex="-1"><a class="header-anchor" href="#_7-缓存" aria-hidden="true">#</a> 7.缓存</h1><ul><li>一级缓存可以使用 redis</li><li>可以加入定时任务定时查询数据并放入缓存中</li><li>二级缓存可以使用 caffine，但是可能导致数据不一致</li></ul><br><h1 id="_8-分库分表" tabindex="-1"><a class="header-anchor" href="#_8-分库分表" aria-hidden="true">#</a> 8.分库分表</h1><ul><li>查看数据库连接资源是否不足，不足时使用分库</li><li>单表数据量太大时可以使用分表</li></ul><br><h1 id="_9-其他" tabindex="-1"><a class="header-anchor" href="#_9-其他" aria-hidden="true">#</a> 9.其他</h1>',28),s=l("li",null,[l("p",null,"开启慢查询日志："),l("ul",null,[l("li",null,"slow_query_log：慢查询开关"),l("li",null,"slow_query_log_file：慢查询日志存放的路径"),l("li",null,"long_query_time：超过多少秒才会记录日志")])],-1),_={href:"https://prometheus.io/",target:"_blank",rel:"noopener noreferrer"},c=l("ul",null,[l("li",null,"接口响应时间"),l("li",null,"调用第三方接口的耗时"),l("li",null,"慢查询耗时"),l("li",null,"CPU 使用情况"),l("li",null,"内存使用情况"),l("li",null,"磁盘使用情况"),l("li",null,"数据库使用情况")],-1),f={href:"https://skywalking.apache.org/",target:"_blank",rel:"noopener noreferrer"};function p(b,x){const e=u("ExternalLinkIcon");return n(),t("div",null,[d,l("ul",null,[s,l("li",null,[l("p",null,[i("加入监控（"),l("a",_,[i("Prometheus"),a(e)]),i("）：")]),c]),l("li",null,[l("p",null,[i("链路追踪（"),l("a",f,[i("skywalking"),a(e)]),i("）")])])])])}const g=r(o,[["render",p],["__file","性能优化方向-已发布.html.vue"]]);export{g as default};
