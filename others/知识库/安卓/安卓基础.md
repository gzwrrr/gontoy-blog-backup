# 安卓基础



## 权限

Android 系统实现了*最小权限原则*。换言之，默认情况下，每个应用只能访问执行其工作所需的组件，而不能访问其他组件。这样便能创建非常安全的环境，在此环境中，应用无法访问其未获得权限的系统部分。不过，应用仍可通过一些途径与其他应用共享数据以及访问系统服务：

- 可以安排两个应用共享同一 Linux 用户 ID，在此情况下，二者便能访问彼此的文件。为节省系统资源，也可安排拥有相同用户 ID 的应用在同一 Linux 进程中运行，并共享同一 VM。应用还必须使用相同的证书进行签名。
- 应用可以请求访问设备数据（如用户的联系人、短信消息、可装载存储装置（SD 卡）、相机、蓝牙等）的权限。用户必须明确授予这些权限。如需了解详细信息，请参阅[使用系统权限](https://developer.android.google.cn/training/permissions?hl=zh-cn)。



## 日志

五个级别（Log）

APP 开发模式

1. 原生开发（Java + Kotlin）重用户体验
2. 混合开发（Flutter、前端）

也有可能使用 JNI 调用 C++ 的代码



## 四大组件

应用组件是 Android 应用的基本构建块。每个组件都是一个入口点，系统或用户可通过该入口点进入您的应用。有些组件会依赖于其他组件。

共有四种不同的应用组件类型：

- Activity：前台
- 服务：后台
- 广播接收器
- 内容提供程序

每种类型都有不同的用途和生命周期，后者会定义如何创建和销毁组件。以下部分将介绍应用组件的四种类型。



启动组件：在四种组件类型中，有三种（Activity、服务和广播接收器）均通过异步消息 *Intent* 进行启动。Intent 会在运行时对各个组件进行互相绑定。您可以将 Intent 视为从其他组件（无论该组件是属于您的应用还是其他应用）请求操作的信使。





## 工程结构

两个层次（一个项目中有多个模块）

1. 项目
2. 模块

项目结构：

**app：**

1. manifests：AndroidManifest.xml
2. java：源码 + 单元测试
3. res：当前模块的资源文件
   1. drawable：绘制的图像、可以适配
   2. layout：项目布局
   3. mipmap：存放 APP 图标（矢量图标）
   4. values：颜色值、主题

**gradle script：**

1. `build.gradle`：分为项目和模块，用于描述 APP 工程的编译规则
2. `proguard-rules.pro`：混淆规则
3. `gradle.properties`：环境变量
4. `settings.gradle`：配置需要编译的模块，初始内容为 `include ':app'`，表示只编译 APP 模块
5. `local.properties`：项目的本地配置文件，在项目编译时自动生成，描述了本地开发环境的配置信息





## 编译打包

注意点：编译工具版本需要和构建工具版本匹配

应用元数据（defaultConfig）

1. applicationId：APP 包名
2. minSdkVersion：最小版本号
3. targetSdkVersion：期望运行版本号
4. versionCode：APP 应用的版本号
5. versionName：APP 应用的版本名称





## 应用配置

### AndroidManifest.xml

包含以下几个部分：

1. 运行配置、备份等
2. Activity：应用程序组件



## 界面绘制

> 控件都可以称为 View 或者视图

两种方式；

1. XML
2. 硬编码

中级控件

高级控件

自定义控件



### 尺寸

> 相关文章：https://www.jb51.net/article/113125.htm

相关知识点：

| 单位/概念  | 说明                                                         |
| ---------- | ------------------------------------------------------------ |
| px         | 像素（Pixel），是屏幕上的最小可操作单元，通常用于表示图像或屏幕上的点 |
| resolution | 分辨率，表示屏幕上水平和垂直方向的像素数量，通常以宽x高的形式表示，例如1920x1080 |
| dpi        | 每英寸点数（Dots Per Inch），表示每英寸的线性像素密度，用于测量屏幕或图像的清晰度 |
| density    | 密度，通常指屏幕像素密度或显示设备的像素密度，通常以DPI（每英寸点数）表示 |
| inch       | 英寸，1 英寸约等于2.54厘米，主要用来描述手机屏幕的大小       |
| pt         | 通常用来作为字体的尺寸单位，1 pt相当于1/72英寸               |
| sp         | 大部分人只知道它通常用作字体的尺寸单位，实际大小还与具体设备上的用户设定有关 |
| dp（dip）  | 即设备无关像素（device independent pixels），这种尺寸单位在不同设备上的物理大小相同 |

dpi：像素密度

- ldpi：对应的dpi范围为0 ~ 120，也就是说每英寸有0到120个像素点的屏幕的屏幕密度都属于ldpi
- mdpi：dpi范围为120 ~ 160
- hdpi：dpi范围为160 ~ 240
- xhdpi：dpi范围为240~320
- xxhdpi：dpi范围为320~480

> px = dip x dpi / 160

对于相同尺寸的手机，即使分辨率不一样，同 dp 的组件占用屏幕的比例也相同





### 视图/布局

视图：

1. ScrollView 垂直滚动视图
2. HorizontalScrollView 水平滚动视图

布局：

1. LinearLayout 线性布局：水平、垂直、权重
2. RelativeLayout 相对布局：[相关文章](https://blog.csdn.net/ZQIR12/article/details/127822301)
3. GridLayout 网格布局

其他：

1. layout_width、layout_height：wrap_content、match_parent、固定大小
2. ViewGroup、Context（Resource）
3. 对齐（layout_gravity、gravity）
4. orientation=vertical/horizontal





### 简单控件

:::info 相关文章

[Android 常用的控件总结](https://blog.csdn.net/weixin_49770443/article/details/117327634)

:::



:::note 说明（XML）

注意点：需要注意命名空间

代码中获取 XML 中的组件使用 R 类（gradle 自动生成）直接获取

层次结构：

1. layout
2. id

引用：

1. 唯一 ID：@+id/
2. 引用组件：@string/

:::



文本：设置文本的：内容、颜色、宽高

1. TextView（文本框）
2. EditView（输入框）
3. AutoCompleteTextView

选择框：

1. RadioGroup（单选）
2. CheckBox（多选）

按钮：

1. Button：由 TextView 派生而来
   1. onClick 点击事件（不推荐直接使用，应当使用监听器）
   2. setOnClickListener 设置监听（实现 View.onOnClickListener）
   3. setOnLongClickListener 长按点击事件
   4. 双击事件
   5. 可用/禁用
2. ImageButton（图像按钮）
3. ToggleButton（开关）
4. RadioButtun（单选按钮）

图像：

1. ImageView
2. ImageButton：继承于 ImageView
3. 同时展示文本和图像：ImageView + TextView、Button 的 drawable 属性
4. ImageSwitcher/Gallery

列表：

1. Spinner：下拉列表
2. ListView：列表

日期/时间：

1. DatePicker：日期选择器
2. TimePicker：时间选择器

提示/对话框：

1. Toast（提示）
2. Dialog（对话）

进度条：

1. ProgressBar：进度条
2. ProgressDialog：对话框中的进度条

其他：

1. SeekBar：拖动条
2. RatingBar：评分组件





## Activity



父类：AppCompatActivity

**onCreate：**

1. Bundle：包（类似上下文）
2. Intent：意图

```java
public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        TextView textView = findViewById(R.id.tv);
        textView.setText("你好！");

        Button button = findViewById(R.id.bt);
        button.setOnClickListener(v -> {
            Intent intent = new Intent();
            intent.setClass(MainActivity.this, MainActivity2.class);
            startActivity(intent);
        });
    }
}
```



startActiviy：可以用于跳转页面



### 生命周期

:::info 相关文章

[官方文档](https://developer.android.google.cn/guide/components/activities/activity-lifecycle?hl=zh-cn#java)

:::

为了在 Activity 生命周期的各个阶段之间导航转换，Activity 类提供六个核心回调：`onCreate()`、`onStart()`、`onResume()`、`onPause()`、`onStop()` 和 `onDestroy()`。当 Activity 进入新状态时，系统会调用其中每个回调。

![img](https://developer.android.google.cn/guide/components/images/activity_lifecycle.png?hl=zh-cn)

#### onCreate

1. 在系统首次创建 Activity 时触发。Activity 会在创建后进入“已创建”状态。
2. 在 `onCreate()` 方法中，您需执行基本应用启动逻辑，该逻辑在 Activity 的整个生命周期中**只应发生一次**。
3. 例如，`onCreate()` 的实现可能会将数据绑定到列表，将 `Activity` 与 `ViewModel` 相关联，并实例化某些类作用域变量。此方法会接收 `savedInstanceState` 参数，后者是包含 Activity 先前保存状态的 `Bundle` 对象。如果 Activity 此前未曾存在，`Bundle` 对象的值为 null。
4. 还可以在 Activity 代码中新建 `View` 对象，并将新建的 `View` 插入到 `ViewGroup` 中，以构建视图层次结构。然后，将根 `ViewGroup` 传递给 `setContentView()` 以使用该布局（[参考](https://developer.android.google.cn/guide/topics/ui?hl=zh-cn)）
5. `onCreate()` 方法完成执行后，Activity 进入“已开始”状态，系统会相继调用 `onStart()` 和 `onResume()` 方法。



#### onStart

1. 当 Activity 进入“已开始”状态时，系统会调用此回调。`onStart()` 调用使 Activity 对用户可见，因为应用会为 Activity 进入前台并支持互动做准备。
2. 当 Activity 进入已开始状态时，与 Activity 生命周期相关联的所有生命周期感知型组件都将收到 [`ON_START`](https://developer.android.google.cn/reference/androidx/lifecycle/Lifecycle.Event?hl=zh-cn#ON_START) 事件。
3. `onStart()` 方法会非常快速地完成，并且与“已创建”状态一样，Activity 不会一直处于“已开始”状态。一旦此回调结束，Activity 便会进入“已恢复”状态，系统将调用 `onResume()` 方法。



#### onResume

:::warning 注意

事件在何时触发需要慎重，会影响用户体验（[参考](https://developer.android.google.cn/guide/components/activities/activity-lifecycle?hl=zh-cn#java)）

:::

1. Activity 会在进入“已恢复”状态时来到前台，然后系统调用 `onResume()` 回调。这是应用与用户互动的状态。
2. 应用会一直保持这种状态，直到某些事件发生，让焦点远离应用。此类事件包括接到来电、用户导航到另一个 Activity，或设备屏幕关闭。
3. 当 Activity 进入已恢复状态时，与 Activity 生命周期相关联的所有生命周期感知型组件都将收到 [`ON_RESUME`](https://developer.android.google.cn/reference/androidx/lifecycle/Lifecycle.Event?hl=zh-cn#ON_RESUME) 事件。
4. 当发生中断事件时，Activity 进入“已暂停”状态，系统调用 `onPause()` 回调。如果 Activity 从“已暂停”状态返回“已恢复”状态，系统将再次调用 `onResume()` 方法。
5. 应实现 `onResume()`，以初始化在 [`onPause()`](https://developer.android.google.cn/reference/android/app/Activity?hl=zh-cn#onPause()) 期间释放的组件，并执行每次 Activity 进入“已恢复”状态时必须完成的任何其他初始化操作。
6. 无论选择在哪个构建事件中执行初始化操作，都务必使用相应的生命周期事件来释放资源：
   1. 如果在收到 ON_START 事件后初始化某些内容，那么就在收到 ON_STOP 事件后释放或终止相应内容
   2. 如果在收到 ON_RESUME 事件后初始化某些内容，那么就在收到 ON_PAUSE 事件后将其释放

:::warning 注意

可以将组件初始化代码放置在生命周期感知型组件中，也可以直接将此代码放入 Activity 生命周期回调（例如 [`onStart()`](https://developer.android.google.cn/reference/android/app/Activity?hl=zh-cn#onStart()) 和 [`onStop()`](https://developer.android.google.cn/reference/android/app/Activity?hl=zh-cn#onStop())），但官方不建议这样做。

通过将此逻辑添加到独立的生命周期感知型组件中，可以对多个 Activity 重复使用该组件，而无需复制代码（参阅：[使用生命周期感知型组件处理生命周期](https://developer.android.google.cn/topic/libraries/architecture/lifecycle?hl=zh-cn)）

:::



#### onPause

1. 系统将此方法视为用户将要离开 Activity 的第一个标志（尽管这并不总是意味着 Activity 会被销毁）
2. 此方法表示 Activity 不再位于前台（尽管在用户处于多窗口模式时 Activity 仍然可见）
3. 在此方法中，**暂停或调整**处于**暂停状态**时，不应该继续或者应该尽量少调用或者希望快速恢复的操作
4. 进入暂停状态的原因包括：
   1. 某个事件会中断应用执行（最常见的情况）
   2. 在 Android 7.0（API 级别 24）或更高版本中，有多个应用在多窗口模式下运行。无论何时，都只有一个应用（窗口）可以拥有焦点，因此系统会暂停所有其他应用。
   3. 有新的半透明 Activity（例如对话框）处于开启状态。只要 Activity 仍然部分可见但并未处于焦点之中，它便会一直暂停。
   4. 当 Activity 进入已暂停状态时，与 Activity 生命周期相关联的所有生命周期感知型组件都将收到 [`ON_PAUSE`](https://developer.android.google.cn/reference/androidx/lifecycle/Lifecycle.Event?hl=zh-cn#ON_PAUSE) 事件。这时，生命周期组件可以停止在组件未位于前台时无需运行的任何功能，例如停止相机预览。
5. `onPause()` 执行非常简单，而且不一定要有足够的时间来执行保存操作。因此，**不应使用** `onPause()` 来保存应用或用户数据、进行网络调用或执行数据库事务。因为在该方法完成之前，此类工作可能无法完成（应在 `onStop()` 期间执行高负载的关闭操作。[参阅 onStop()](https://developer.android.google.cn/guide/components/activities/activity-lifecycle?hl=zh-cn#onstop)。如需详细了解如何保存数据（参阅：[保存和恢复 Activity 状态](https://developer.android.google.cn/guide/components/activities/activity-lifecycle?hl=zh-cn#saras)））

:::warning 注意

还可以使用 [`onPause()`](https://developer.android.google.cn/reference/android/app/Activity?hl=zh-cn#onPause()) 方法释放系统资源、传感器（例如 GPS）手柄，或当 Activity 暂停且用户不需要它们时仍然可能影响电池续航时间的任何资源。

然而，如果处于多窗口模式，“已暂停”的 Activity 仍完全可见。因此，应该考虑使用 onStop() 而非 onPause() 来完全释放或调整与界面相关的资源和操作，以便更好地支持多窗口模式。

:::



#### onStop

1. 如果 Activity 不再对用户可见，说明其已进入“已停止”状态，因此系统将调用 `onStop()` 回调。
2. 当 Activity 进入已停止状态时，与 Activity 生命周期相关联的所有生命周期感知型组件都将收到 [`ON_STOP`](https://developer.android.google.cn/reference/androidx/lifecycle/Lifecycle.Event?hl=zh-cn#ON_STOP) 事件。这时，生命周期组件可以停止在组件未显示在屏幕上时无需运行的任何功能。
3. 在 `onStop()` 方法中，应用应释放或调整在应用对用户不可见时的无用资源。
4. 使用 `onStop()` 而非 `onPause()` 可确保与界面相关的工作继续进行，即使用户在多窗口模式下查看您的 Activity 也能如此。
5. 还应使用 `onStop()` 执行 CPU 相对密集的关闭操作。例如，如果您无法找到更合适的时机来将信息保存到数据库，可以在 `onStop()` 期间执行此操作。
6. 当您的 Activity 进入“已停止”状态时，`Activity` 对象会继续驻留在内存中：该对象将维护所有状态和成员信息，但不会附加到窗口管理器。Activity 恢复后，Activity 会重新调用这些信息。您无需重新初始化在任何回调方法导致 Activity 进入“已恢复”状态期间创建的组件。
7. 系统还会追踪布局中每个 `View` 对象的当前状态，如果用户在 `EditText` 微件中输入文本，系统将保留文本内容，因此您无需保存和恢复文本。
8. 进入“已停止”状态后，Activity 要么返回与用户互动，要么结束运行并消失。如果 Activity 返回，系统将调用 `onRestart()`。如果 `Activity` 结束运行，系统将调用 `onDestroy()`。

:::warning 注意

Activity 停止后，如果系统需要恢复内存，可能会销毁包含该 Activity 的进程。即使系统在 Activity 停止后销毁相应进程，系统仍会保留 `Bundle`（键值对的 blob）中 `View` 对象（例如 `EditText` 微件中的文本）的状态，并在用户返回 Activity 时恢复这些对象。

:::



#### onDestroy

1. 调用该方法可能的原因（可以使用 [`isFinishing()`](https://developer.android.google.cn/reference/android/app/Activity?hl=zh-cn#isFinishing()) 方法区分这两种情况）：
   1. Activity 即将结束（由于用户彻底关闭 Activity 或由于系统为 Activity 调用 [`finish()`](https://developer.android.google.cn/reference/android/app/Activity?hl=zh-cn#finish())）
   2. 由于配置变更（例如设备旋转或多窗口模式），系统暂时销毁 Activity
2. 当 Activity 进入已销毁状态时，与 Activity 生命周期相关联的所有生命周期感知型组件都将收到 [`ON_DESTROY`](https://developer.android.google.cn/reference/androidx/lifecycle/Lifecycle.Event?hl=zh-cn#ON_DESTROY) 事件。这时，生命周期组件可以在 Activity 被销毁之前清理所需的任何数据。
3. 应使用 [`ViewModel`](https://developer.android.google.cn/reference/androidx/lifecycle/ViewModel?hl=zh-cn) 对象来包含 Activity 的相关视图数据，而不是在 Activity 中加入逻辑来确定 Activity 被销毁的原因。这样做之后，如果因配置变更而重新创建 Activity，ViewModel 不必执行任何操作，因为系统将保留 ViewModel 并将其提供给下一个 Activity 实例。如果不重新创建 Activity，ViewModel 将调用 [`onCleared()`](https://developer.android.google.cn/reference/androidx/lifecycle/ViewModel?hl=zh-cn#onCleared()) 方法，以便在 Activity 被销毁前清除所需的任何数据。
4. 如果 Activity 即将结束，onDestroy() 是 Activity 收到的最后一个生命周期回调。如果由于配置变更而调用 onDestroy()，系统会立即新建 Activity 实例，然后在新配置中为新实例调用 [`onCreate()`](https://developer.android.google.cn/reference/android/app/Activity?hl=zh-cn#onCreate(android.os.Bundle))。





### 生命周期事件

| 事件         | 说明           |
| :----------- | -------------- |
| `ON_ANY`     | 所有事件       |
| `ON_CREATE`  | onCreate 事件  |
| `ON_DESTROY` | onDestroy 事件 |
| `ON_PAUSE`   | onPause 事件   |
| `ON_RESUME`  | onResume 事件  |
| `ON_START`   | onStart 事件   |
| `ON_STOP`    | onStop 事件    |

> TODO

| 公共方法                           | 说明                                                         |
| :--------------------------------- | ------------------------------------------------------------ |
| `static final Lifecycle.Event`     | `downFrom(@NonNull Lifecycle.State state)`Returns the `Lifecycle.Event` that will be reported by a `Lifecycle` leaving the specified `Lifecycle.State` to a lower state, or `null` if there is no valid event that can move down from the given state. |
| `static final Lifecycle.Event`     | `downTo(@NonNull Lifecycle.State state)`Returns the `Lifecycle.Event` that will be reported by a `Lifecycle` entering the specified `Lifecycle.State` from a higher state, or `null` if there is no valid event that can move down to the given state. |
| `final @NonNull Lifecycle.State`   | `getTargetState()`Returns the new `Lifecycle.State` of a `Lifecycle` that just reported this `Lifecycle.Event`. |
| `static final Lifecycle.Event`     | `upFrom(@NonNull Lifecycle.State state)`Returns the `Lifecycle.Event` that will be reported by a `Lifecycle` leaving the specified `Lifecycle.State` to a higher state, or `null` if there is no valid event that can move up from the given state. |
| `static final Lifecycle.Event`     | `upTo(@NonNull Lifecycle.State state)`Returns the `Lifecycle.Event` that will be reported by a `Lifecycle` entering the specified `Lifecycle.State` from a lower state, or `null` if there is no valid event that can move up to the given state. |
| `final @NonNull Lifecycle.Event`   | `valueOf(@NonNull String value)`Returns the enum constant of this type with the specified name. |
| `final @NonNull Lifecycle.Event[]` | `values()`Returns an array containing the constants of this enum type, in the order they're declared. |



### 状态变更

> TODO

1. 配置发生了更改
2. Activity 或对话框显示在前台
3. 用户点按“返回”按钮
4. 系统终止应用进程



### ViewModel

1. [`ViewModel`](https://developer.android.google.cn/reference/androidx/lifecycle/ViewModel?hl=zh-cn) 类是一种[业务逻辑或屏幕级状态容器](https://developer.android.google.cn/topic/architecture/ui-layer/stateholders?hl=zh-cn)。

2. 它用于将状态公开给界面，以及封装相关的业务逻辑。

3. 它的主要优点是，它可以缓存状态，并可在配置更改后持久保留相应状态。这意味着在 activity 之间导航时或进行配置更改后（例如旋转屏幕时），界面将无需重新提取数据。



### 生命周期感知型组件

:::info 说明

生命周期感知型组件可执行操作来响应另一个组件（如 activity 和 fragment）的生命周期状态的变化。

这些组件有助于编写出更有条理且往往更精简的代码，此类代码更易于维护。

:::





## TODO List

1. 启停、启动模式
2. 生命周期
3. 意图：显示 Intent 和隐式 Intent
4. 收发数据
5. 利用资源文件配置字符串
6. 利用元数据传递配置信息
7. 注册快捷方式
8. 事件总结
9. 观察者模式总结
10. 生命周期感知型组件
11. [Room 持久性库](https://developer.android.google.cn/topic/libraries/architecture/room?hl=zh-cn)
12. 恢复状态
13. 设备旋转或多窗口模式
14. Activity 状态和从内存中弹出
15. ViewModel
16. Bundle：
    1. [`Bundle`](https://developer.android.google.cn/reference/android/os/Bundle?hl=zh-cn) 对象并不适合保留大量数据，因为它需要在主线程上进行序列化处理并占用系统进程内存。如需保存大量数据，您应组合使用持久性本地存储、[`onSaveInstanceState()`](https://developer.android.google.cn/reference/android/app/Activity?hl=zh-cn#onSaveInstanceState(android.os.Bundle)) 方法和 [`ViewModel`](https://developer.android.google.cn/reference/androidx/lifecycle/ViewModel?hl=zh-cn) 类来保存数据
    2. 重建先前被销毁的 Activity 后，您可以从系统传递给 Activity 的 [`Bundle`](https://developer.android.google.cn/reference/android/os/Bundle?hl=zh-cn) 中恢复保存的实例状态。[`onCreate()`](https://developer.android.google.cn/reference/android/app/Activity?hl=zh-cn#onCreate(android.os.Bundle)) 和 [`onRestoreInstanceState()`](https://developer.android.google.cn/reference/android/app/Activity?hl=zh-cn#onRestoreInstanceState(android.os.Bundle)) 回调方法均会收到包含实例状态信息的相同 [`Bundle`](https://developer.android.google.cn/reference/android/os/Bundle?hl=zh-cn)。
17. Intent：
    1. 根据您的 Activity 是否希望从即将启动的新 Activity 中获取返回结果，您可以使用 `startActivity()` 或 `startActivityForResult()` 方法启动新 Activity。这两种方法都需要传入一个 `Intent` 对象。
    2. `Intent` 对象指定您要启动的具体 Activity，或描述您要执行的操作类型（系统为您选择相应的 Activity，该 Activity 甚至可以来自不同应用）。`Intent` 对象还可以携带由已启动的 Activity 使用的少量数据。如需详细了解 `Intent` 类，请参阅 [Intent 和 Intent 过滤器](https://developer.android.google.cn/guide/components/intents-filters?hl=zh-cn)。





## 其他

1. 通过 R 类获取组件，设置对应的属性
2. 控件的初始化一般放在 onCreate 中
3. 实现监听器后注意要设置成静态的，否则可能发生内存泄露
4. 事件冒泡机制



### resuorce

drawable：矢量资源

values

1. colors.xml
2. strings.xml
3. themes.xml