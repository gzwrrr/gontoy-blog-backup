---
title: "MySQL 索引"
shortTitle: "B-MySQL 索引"
description: "MySQL 索引"
icon: ""
author: 
  name: gzw
  url: 
  email: 1627121193@qq.com
isOriginal: false
date: 2021-05-29
category: 
- "mysql"
- "数据库"
tag:
- "mysql"
- "数据库"
sticky: 1
star: false
article: true
timeline: true
dir:
  text: "MySQL 索引"
  icon: ""
  collapsible: true
  index: true
  comment: true
headerDepth: 3
index: true
order: 2
copy:
  triggerWords: 100
  disableCopy: false
  disableSelection: false
feed:
  title: "MySQL 索引"
  description: "MySQL 索引"
  author:
    name: gzw
    email: 1627121193@qq.com
---





# MySQL 索引

[[toc]]

### 索引类型

:::info 相关文章

[数据库的五种索引类型](https://blog.csdn.net/qq_41793064/article/details/108697472)

[详细介绍mysql索引类型：FULLTEXT、NORMAL、SPATIAL、UNIQUE](https://blog.csdn.net/guo_qiangqiang/article/details/88794971)

:::

| 索引类型                      | 说明                                                         | 使用场景                                                     |
| ----------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 主键索引（Primary Key Index） | 唯一标识一条记录，一个表只能有一个主键索引，一般会自动创建，可用于加速数据的查找和更新操作 | 经常根据主键查询的场景                                       |
| 联合索引（Composite Index）   | 可以覆盖多个数据列，如 INDEX(columnA, columnB) 索引          | 频繁使用的条件放在联合索引的前面可以更好地利用索引，提高查询效率 |
| 唯一索引（Unique Index）      | 值必须唯一，但允许空值，可以用于加速数据的查找和更新操作，避免重复数据的插入 | 需要保证某些列或者组合列的唯一性                             |
| 普通索引（Index）             | 最基本的索引类型，可用于加速数据的查找和排序操作，但不会强制唯一性，允许被索引的数据列包含重复的值 | 经常作为WHERE子句中的列                                      |
| 全文索引（Full-text Index）   | 用于全文搜索的一种特殊索引类型，可以加速全文搜索的查询       | 对文本类型的列进行模糊搜索的场景                             |
| 空间索引（Spatial Index）     | 用于地理空间数据类型的一种特殊索引类型，可以加速空间数据的查询 | 存储位置信息的场景                                           |

需要注意的是，不同类型的索引在使用场景和性能方面有所区别，选择正确的索引类型可以提高数据库的性能。同时，在创建索引时需要考虑索引的数量和列的选择，过多的索引和不合理的列选择可能会影响数据库的性能，因此需要根据具体的场景进行选择和设计。







### 原理

通俗来说，索引就是把 **无序** 的数据变成 **有序** 的查询， 过程大致为：

1. 把创建了索引的列的内容进行排序
2. 对排序结果生成 **倒排表**
3. 在倒排表内容上拼接数据地址链
4. 在查询的时候，先拿到倒排表的内容，再取出数据地址链，从而拿到具体数据

<br/>

索引是数据库优化的重要手段之一，它是一种数据结构，用于加快数据库查询的速度。索引的原理主要涉及以下几个方面：

1. B-Tree 索引：B-Tree 索引是最常见的索引类型。B-Tree 索引是一种平衡树结构，可以有效地支持范围查询、排序查询等操作。B-Tree 索引将所有数据按照索引列的值排序，并在每个节点上存储索引值和指向下一个节点的指针，这样就可以通过二分查找快速定位需要的数据。
2. Hash 索引：Hash 索引是一种哈希表结构，适用于等值查询。Hash 索引将索引列的值计算哈希值，将哈希值作为索引，在哈希表中查找对应的数据。Hash 索引的查询效率非常高，但不支持范围查询、排序查询等操作。
3. 聚簇索引：聚簇索引是一种特殊的索引类型，它的索引键和数据行是存储在一起的。聚簇索引可以使数据的访问更加快速，因为相同索引键的数据行通常都存储在相邻的位置上。
4. 非聚簇索引：非聚簇索引是一种将索引键和数据行分开存储的索引类型。非聚簇索引将索引键和指向数据行的指针分别存储在索引结构和数据表中，这样可以提高查询效率。

索引的原理可以简单概括为将数据按照索引列的值进行排序或哈希，从而快速定位需要的数据。但是，索引也会带来一些负面影响，例如增加数据插入和更新的成本、占用存储空间等。因此，在使用索引时，需要根据具体情况进行合理的设计和使用。











### B 树和 B+ 树

B树和B+树都是常用的数据结构，用于实现数据库索引。它们之间的区别如下：

1. 存储方式：B树中每个节点既存储数据，也存储索引信息；而B+树中只有叶子节点存储数据，非叶子节点只存储索引信息。
2. 叶子节点指针：B树中每个节点都有指向子节点的指针；而B+树中只有叶子节点有指向下一个叶子节点的指针，非叶子节点没有指向下一层的指针。
3. 数据查找：B树可以在所有节点中进行数据查找，而B+树只能在叶子节点中进行数据查找。
4. 节点大小：B树中每个节点存储的数据量比B+树要多，因为B树中每个节点都存储数据；而B+树中每个节点只存储索引信息，因此可以存储更多的索引信息。
5. 磁盘I/O操作：B+树的叶子节点形成一个有序链表，因此可以使用顺序I/O进行读取，效率更高。而B树中，每个节点都存储数据，因此在进行数据查找时需要进行随机I/O操作，效率较低。

综上所述，B+树相对于B树来说，更适用于存储海量数据和范围查询，可以提高数据查询的效率和磁盘I/O操作的效率。而B树则更适用于存储数据量较小的索引，可以提高单次查询的效率。

<br/>

B+树之所以在叶子节点中进行数据查找效率更高，是因为在B+树的叶子节点上采用了链表的形式来存储数据，而且这个链表是有序的，可以进行范围查询。另外，由于所有叶子节点都被链接在一起，可以采用顺序I/O的方式来读取数据，因此可以减少随机I/O的次数，提高了查询效率。

当我们需要查询一条数据时，在B树中，需要从根节点一层一层地向下遍历，直到找到该数据所在的叶子节点，然后再在该节点中进行数据查找。由于B树中每个节点都存储数据，因此需要进行多次随机I/O操作，这会严重影响查询效率。

而在B+树中，只需要进行一次二分查找就可以找到对应的叶子节点，然后通过链表遍历就可以查找到该数据。由于叶子节点是有序的，可以进行范围查询，这在处理一些数据量较大的范围查询时效率更高。同时，由于数据只存在于叶子节点中，而非叶子节点只存储索引信息，因此B+树的高度相对较小，可以进一步减少随机I/O的次数，提高查询效率。

综上所述，B+树在叶子节点中寻找数据的方式可以提高查询效率，并且链表结构的形式也为范围查询提供了便利。

<br/>

MySQL 索引使用的是 B+ 树，因为索引是用来加速查询的，而 B+ 树通过对数据进行排序所以是可以提高查询速度的。由于一个节点中可以存储多个元素，所以 B+ 树的高度一般都不会太高。在 MySQL 中一个 InnoDB 页就是一个 B+ 树节点，该页默认为 16kb，所以一般情况下一颗 **两层** 的 B+ 树可以存储 2000 万行左右的数据，然后通过利用叶子节点存储的所有数据进行排序，可以很好地支持全表扫描、范围查询等语句





### 索引设计原则

1. 适合索引的列是出现在 **where** 子句中的列，或者 **连接子句** 中指定的列
2. 基数较小的类的索引效果较差，没有必要在此列建立索引
3. 使用短索引：如果对长字符串进行索引，应该指定一个前缀长度，这样能够节省大量索引空间，如果搜索词超过索引前缀长度，则使用索引排除不匹配的行，然后检查其余索引是否可以匹配
4. 定义有 **外键** 的列一定建立索引
5. 更新频繁的字段不适合建立索引
6. 不能有效区分数据的列不适合做索引（如性别）
7. 加索引时尽量扩展索引而不是直接添加，例如已经有了 a 索引，那么只需要修改原来的索引从而达成 (a, b)
8. 对于查询中很少涉及到的列，且重复值较多的列不适合建立索引
9. 对于定义为 text、image、bit 的数据类型的列不适合建立索引



### 索引使用注意点

1. 索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么将无法使用索引。索引页面搜索中严禁 **左模糊** 和 **全模糊**，是在需要那么应该用专门的搜索引擎
2. 对于索引选择性太差的查询语句，查询优化器可能会直接选择全表扫描。比如查询手机号码时，建立了对应字段的索引，但是使用了 `1%` 作为模糊查询的条件，那么大概率会直接走全表扫描
3. 索引和执行时间没有必然的关系，确定查询执行效率的是：**扫描行数** 和 **回表次数**



### 索引优化

1. 增加多种不同规格索引以提高索引选择性（5~6组）
2. 空间换时间：使用定时任务增加时报、日报等中间结果
3. 边缘运算数据压缩（分布式计算后压缩成少量信息再上报）
4. 硬件调优：增大 `innodb_buffer_pool` ，即增大内存减少硬盘回表



### 索引覆盖

就是一个 SQL 执行时，可以利用索引来快速查找，并且此 SQL 所要查询的字段在当前索引对应的字段中都包含了，那么就表示此 SQL 走完索引后不用回表，所需要的字段都在当前索引的叶子节点上存在，可以直接作为结果返回



### 执行计划

Explain 各个字段的含义

| 字段名称      | 含义                                                         |
| ------------- | ------------------------------------------------------------ |
| id            | 每个表或者查询的子查询都有一个唯一的标识符。在执行查询时，MySQL会根据这些标识符按照某种顺序依次执行查询操作。 |
| select_type   | 查询类型，常见的类型包括SIMPLE（简单查询）、PRIMARY（主查询）、UNION（联合查询）等。 |
| table         | 查询涉及到的表的名称。                                       |
| partitions    | 如果查询使用了分区表，该字段会显示查询使用的分区。           |
| type          | MySQL在执行查询时使用的访问方式，常见的访问方式包括ALL（全表扫描）、index（索引扫描）、range（范围扫描）、ref（使用非唯一索引或唯一索引的前缀进行匹配）等。 |
| possible_keys | MySQL可以使用的索引列表，多个索引以逗号分隔。                |
| key           | MySQL实际使用的索引，如果为NULL，则表示没有使用索引。        |
| key_len       | MySQL在使用索引时使用的索引长度。                            |
| ref           | MySQL在使用索引时使用的列或者常量。                          |
| rows          | MySQL在执行查询时估计需要扫描的行数。                        |
| filtered      | 查询结果的行数在返回结果集之前被过滤掉的百分比。             |
| Extra         | 包含了一些额外的信息，例如是否使用了临时表、是否使用了文件排序等。 |

==id==：是一个有顺序的编号，是查询的顺序号，有几个 select 就显示几行。id的顺序是按 select 出现的顺序增长的。id列的值越大执行优先级越高越先执行，id列的值相同则从上往下执行，id列的值为NULL最后执行。



==selectType==: 表示查询中每个select子句的类型：

1. SIMPLE： 表示此查询不包含 UNION 查询或子查询
2. PRIMARY： 表示此查询是最外层的查询（包含子查询）
3. SUBQUERY： 子查询中的第一个 SELECT
4. UNION： 表示此查询是 UNION 的第二或随后的查询
5. DEPENDENT UNION： UNION 中的第二个或后面的查询语句, 取决于外面的查询
6. UNION RESULT, UNION 的结果
7. DEPENDENT SUBQUERY: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.
8. DERIVED：衍生，表示导出表的SELECT（FROM子句的子查询）



==type==：优化sql的重要字段，也是我们判断sql性能和优化程度重要指标。他的取值类型范围：

1. const：通过索引一次命中，匹配一行数据
2. system: 表中只有一行记录，相当于系统表；
3. eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配
4. ref: 非唯一性索引扫描,返回匹配某个值的所有
5. range: 只检索给定范围的行，使用一个索引来选择行，一般用于between、<、>；
6. index: 只遍历索引树；
7. ALL: 表示全表扫描，这个类型的查询是性能最差的查询之一。 那么基本就是随着表的数量增多，执行效率越慢。



==rows==：mysql 查询优化器根据统计信息，估算该sql返回结果集需要扫描读取的行数，这个值相关重要，索引优化之后，扫描读取的行数越多，说明索引设置不对，或者字段传入的类型之类的问题，说明要优化空间越大



==filtered==：返回结果的行占需要读到的行(rows列的值)的百分比，就是百分比越高，说明需要查询到数据越准确， 百分比越小，说明查询到的数据量大，而结果集很少



==extra==：

1. using filesort ：表示 mysql 对结果集进行外部排序，不能通过索引顺序达到排序效果。一般有using filesort都建议优化去掉，因为这样的查询 cpu 资源消耗大，延时大。
2. using index：覆盖索引扫描，表示查询在索引树中就可查找所需数据，不用扫描表数据文件，往往说明性能不错。
3. using temporary：查询有使用临时表, 一般出现于排序， 分组和多表 join 的情况， 查询效率不高，建议优化。
4. using where ：sql使用了where过滤,效率较高





### 最左前缀原则

最左前缀原则是指对于一个联合索引（复合索引）来说，如果在查询语句中只使用了该联合索引的前缀部分，那么MySQL就可以利用这个联合索引进行数据的匹配和查询。

具体来说，如果一个联合索引包含多个列，那么在查询时必须满足以下条件：

1. 查询语句中的条件从联合索引的最左侧开始；
2. 查询时只能使用联合索引的连续一段，不能跳过中间的列；
3. 如果在联合索引的某个列上使用了范围查询（例如 BETWEEN、>、< 等），那么该列右侧的所有列都无法使用索引。

最左前缀原则的作用在于优化查询语句的性能。如果一个表有多个列需要使用索引，可以考虑建立一个联合索引来提高查询效率。但是需要注意的是，在建立联合索引时，要根据最常用的查询顺序来决定索引的顺序，以保证最左前缀原则的使用。





