---
title: "JVM 常见问题"
shortTitle: "Z-JVM 常见问题"
description: "JVM 常见问题"
icon: ""
author: 
  name: gzw
  url: 
  email: 1627121193@qq.com
isOriginal: false
date: 2022-06-11
category: 
- "java"
- "JVM"
- "虚拟机"
tag:
- "java"
- "JVM"
- "虚拟机"
sticky: 1
star: false
article: true
timeline: true
dir:
  text: "JVM 常见问题"
  icon: ""
  collapsible: true
  index: true
  comment: true
headerDepth: 3
index: true
order: 2
copy:
  triggerWords: 100
  disableCopy: false
  disableSelection: false
feed:
  title: "JVM 常见问题"
  description: "JVM 常见问题"
  author:
    name: gzw
    email: 1627121193@qq.com
---



# JVM 常见问题



[[toc]]



## Tomcat 中为什么使用自定义类加载器

`Tomcat` 中可以部署多个应用，每个应用中都存在许多类，并且各个应用中的类是独立的，但是其全类名是可以 **相同的**，使用自定义类加载器可以避免至加载一个类，做法就是为部署的 **每个应用都生成一个类加载器示例**，名称为 `WebAppClassLoader`

另外 `Tomcat` 还利用自定义加载器实现了 **热加载** 功能





## 如何排查 JVM 问题

**对于还在正常运行的系统：**

1. 可以使用 jmap 来查看 JVM 中各个区域的情况
2. 可以通过 jstack 来查看线程的运行情况，比如哪些线程阻塞了，哪些线程死锁了
3. 可以通过 jstat 命令来查看垃圾回收情况，特别是 fullgc，如果发现 fullgc 比较频繁，那么就需要调优
4. 通过各个命令的结果，使用 jvisualvm 等工具进行分析
5. 可以初步猜测是频繁 fullgc 的原因，此时可能一直没有内存溢出，表示此时实际上回收了很多对象，所以这些对象最好能够是在 younggc 阶段就直接回收，避免这些对象进入老年代。对于这种情况，就要考虑这些存活时间不长的对象是不是比较大，从而导致年轻代放不下就直接到了老年代，此时可以加大年轻代的大小，改完后如果 fullgc 减少说明有效
6. 还可以找到占用 CPU 最多的线程，定位到具体的方法，优化这个方法的执行，看看是否能避免创建某些对象，从而节省内存

**对于已经发生了 OOM 的系统：**

1. 一般生产系统中都会设置当系统发生 OOM 时，生成当时的 dump 文件（`-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/usr/local/base`）
2. 可以利用 jvisualvm 工具来分析 dump 文件
3. 根据 dump 文件找到发生异常的示例对象，和异常的线程（占用 CPU 高），定位到具体的代码

调优不是一蹴而就，需要分析、推理、实践、总结再分析，最终定位到具体问题







## 一个对象加载到 JVM 再到被 GC 清除，都经历了什么过程？

1. 首先是把字节码文件的内容加载到方法区
2. 然后根据类信息在堆区创建对象
3. 对象首先会分配在堆区中年轻代的伊甸园区，经过以此 Minor GC 之后，对象如果还存会，就会进入幸存者区。后续的还会发生若干次 Minor GC，如果对象一直存活着，那么就会在幸存者区来回拷贝，每移动一次，年龄就会加一
4. 当年龄大于 15 后，如果对象依然存活，对象就会进入老年代
5. 如果经过 Full GC，被标记成为了垃圾对象，那么就会被 GC 线程清理掉





## 怎么确定一个对象是否为垃圾？

1. 引用计数算法：这种方式是给堆内存中的每个对象记录一个引用值，引用这个数为 0 就被认为是垃圾。这是早期 JDK 使用的方式。但是注意：引用计数无法解决循环引用的问题
2. 可达性算法：这种方式是在内存中的，从跟对象一直向下找引用，找到的对象就不是垃圾，没有找到的对象就是垃圾





## JVM 有哪些垃圾回收算法？

**主要有三种：**

1. 标记清除算法：

   - 标记阶段：把垃圾内存标记出来

   - 清理阶段：直接将垃圾内存回收

   - 这种算法比较简单，但是会产生大量的 **内存碎片**

2. 复制算法：

   - 为了解决标记算法产生的内存碎片问题，就有了复制算法

   - 复制算法将内存分为大小相等的两部分，每次只使用其中的一半
   - 垃圾回收时，将当前这一块的存活对象全部拷贝到另外一半，然后当前着一半内存就直接清除
   - 这种方法没有内存碎片，但是很浪费空间，而且效率跟存活的对象数量有关

3. 标记压缩算法：

   - 为了解决复制算法的缺陷，就有了标记压缩算法
   - 这种算法在标记阶段跟标记清除算法时一样的
   - 但是完成标记之后，不是直接清理垃圾内存，而是将存活对象往一端移动，然后将边界以外的所有内存直接清除







## 什么是 STW？

- STW：Stop-The-World，是在垃圾回收算法执行过程中，需要将 JVM 内存 **冻结** 的一种状态
- 在此状态下，java 所有线程都是停止执行的（除了 GC 线程外和 native 方法），并且不能跟 JVM 交互
- 各种 GC 算法优化的重点，就是减少 STW，同时这也是 JVM 调优的重点





## JVM 参数有哪些？

**大致可以分为三类：**

1. 标注指令：`-` 开头，这些是所有的 HotSpot 都支持的参数 ，可以使用 `java -help` 打印出来
2. 非标注指令：`-X` 开头，这些指令通常是跟特定的 HotSpot 版本对应的，可以使用 `java -X` 打印出来
3. 不稳定参数：`-XX` 开头，这一类参数是跟特定的 HotSpot 版本对应的，并且变化非常大













