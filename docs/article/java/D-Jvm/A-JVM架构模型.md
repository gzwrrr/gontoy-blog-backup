---
title: "JVM 架构模型"
shortTitle: "A-JVM 架构模型"
description: "JVM 架构模型"
icon: ""
author: 
  name: gzw
  url: 
  email: 1627121193@qq.com
isOriginal: false
date: 2022-06-11
category: 
- "java"
- "JVM"
- "虚拟机"
tag:
- "java"
- "JVM"
- "虚拟机"
sticky: 1
star: false
article: true
timeline: true
dir:
  text: "JVM 架构模型"
  icon: ""
  collapsible: true
  index: true
  comment: true
headerDepth: 3
index: true
order: 2
copy:
  triggerWords: 100
  disableCopy: false
  disableSelection: false
feed:
  title: "JVM 架构模型"
  description: "JVM 架构模型"
  author:
    name: gzw
    email: 1627121193@qq.com
---





# JVM 架构模型



[[toc]]



JVM 的具体实现常见的有：

> 标 * 的是最常用的三大虚拟机

- *Hotspot（最常用，在各个平台都有涉及）
- *Jrocket（曾经号称最快，专注于服务器端，后来部分特性并入 Hotspot）
- *J9（IBM 自己的 VM 实现）
- TaobaoVM（Hotspot 定制版，大型厂商使用）
- LiquidVM（直接对接硬件）
- Zing（垃圾回收最快，回收算法之后被并入了 Hotspot）

注：Hotspot 访问对象采用的是直接指针访问（不是用句柄池）



## Java 编译器

Java 编译器（hotspot）输入的指令流是基于「栈」的指令集架构，还有一种是基于「寄存器」的指令集架构

**基于栈的架构的特点：**

- 设计和实现简单，适用于资源受限的系统
- 避开了寄存器分配难题，可以直接使用零地址指令分配方式
- 指令流中的指令操作过程依赖于操作栈，指令集更小，编译器实现更容易
- 不需要硬件支持，可移植性更好，更好实现跨平台

**基于寄存器架构的特点：**

- 典型的应用是 x86 的二进制指令集：比如传统的 PC 以及 Android 的 Davlik 虚拟机
- 指令集架构则完全依赖硬件，可移植性差
- 性能优秀和执行更高效
- 花费更少的指令去完成一项操作
- 在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主



## JVM 的生命周期

### 启动

- Java虚拟机的启动是通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的
- 这个类是由虚拟机的具体实现指定的



### 执行

- 一个运行中的Java虚拟机有着一个清晰的任务∶执行Java程序
- 程序开始执行时他才运行，程序结束时他就停止
- 执行一个所谓的 Java 程序的时候，真真正正在执行的是一个叫做 Java 虚拟机的进程。



### 退出

- 程序在执行过程中遇到了异常或错误而异常终止
- 由于操作系统出现错误而导致Java虚拟机进程终止
- 某线程调用 Runtime 类或 System 类的 exit 方法，或 Runtime 类的 halt 方法，并且 Java 安全管理器也允许这次 exit 或 halt 操作
- 除此之外，JNI（ Uava Native Interface）规范描述了用 JNI Invocation API 来加载或卸载 Java 虚拟机时，Java虚拟机的退出情况



## 类加载器

:::info 相关文章

1. [JVM基础（三）一个对象的创建过程](https://zhuanlan.zhihu.com/p/142614439)
2. [请你说说Java类的加载过程](https://blog.csdn.net/qq_41563912/article/details/116642556)
3. [面试干货4——你对Java类加载器(自定义类加载器)有了解吗？](https://blog.csdn.net/qq_41563912/article/details/118028251?spm=1001.2014.3001.5501)

:::

- 负责从文件系统或网络中加载 Class 文件（Class 文件头有特定的标识）

- ClassLoader 只负责 Class 文件的加载，是否能执行由执行引擎决定
- 加载的类信息存放在「方法区」中
- Class 文件是存储在磁盘上的，而 JVM 中实例化对象是需要模板的，ClassLoader 就是将 Class 文件转换成二进制模板（DNA 元数据模板，在方法区中）
- 类加载分为三个过程：
  - 加载
  - 链接
  - 初始化

**加载 Class 文件的方式：**

- 从本地系统中直接加载
- 通过网络获取（Applet）

- 从 zip 压缩包中读取（例如读取 jar、war 包）
- 运行时动态生成（动态代理）
- 由其他文件生成（JSP）
- 从专有数据库中提取 Class 文件
- 从加密文件中获取（防止 Class 文件被反编译的保护措施）



### 加载

- 通过一个类的「全限定名」获取该类的二进制流文件
- 将这个字节流代表的「静态存储结构」转化为方法区的「运行时数据结构」
- 在内存中生成一个代表这个类的 `Java.lang.Class` 对象，作为方法区中这个类的各种数据的「访问入口」



### 链接

**验证：**

- 确保 Class 文件字节流信息符合当前虚拟机实现的要求，保证类加载安全的同时，不会危害到虚拟机自身的安全
- 主要包括四种验证：
  - 文件格式验证
  - 元数据验证
  - 字节码验证
  - 符号引用验证

**准备：**

- 为类「分配内存」并设置该类的成员变量的「初始值为零值」（不包含用 final 修饰的 static 变量，因为 final 变量在编译的时候就分配了内存，在准备阶段会显示的初始化）
- 该阶段不会为实例变量初始化，类的变量会分配在方法区中，而实例变量会随实例对象一起分配在 Java 堆中

**解析：**

- 符号引用：用一组符号来描述所引用的目标，符号引用的「字面量形式」定义在 Class 文件中
- 直接引用：直接指向目标的指针、相对偏移量、间接定位到目标的句柄
- 解析就是将常量池中的「符号引用」转换为「直接引用」的过程
- 解析操作一般是 JVM 在执行完初始化操作后再执行的
- 解析动作主要针对「类」、「接口」、「字段」、「类方法」、「接口方法」、「方法类型」等。这些对应着常量池中的：`CONSTANT_CLass_info`、`CONSTANT_Fieldref_info`、`CONSTANT_Methodref_info` 等字段



### 初始化

- 初始化阶段执行类构造器方法：`<clinit>()` 过程
- 此方法不用定义，由 javac 编译器自动收集类中的所有「类变量」的赋值动作和「静态代码块」中的语句而合并来的（构造器方法是「虚拟机」视角下的 `<init>()` ）
- 构造器方法中指令按语句再源文件中出现的顺序执行
- 若该类具有父类，那么 JVM 会保证子类的 `<clinit>()` 方法执行前先执行完父类的 `<clinit>()`

- 虚拟机必须保证一个类的 `<clinit>()` 方法在多线程下被「同步加锁」



## 类加载器的分类

> 分为引导类加载器（Bootstrap ClassLoader，使用 C 语言实现）和自定义类加载器（User-Defined ClassLoader，使用 Java 实现）

- 自定义类加载器一般是由开发人员自定义的
- 但是 JVM 规范是将所有「派生于」ClassLoader 的类加载器都划分为自定义加载器
- 但是无论怎么划分，最常见的类加载器只有三种：
  - Bootstrap ClassLoader（加载 Java 核心 API 中的类，该类加载器无法获取）
  - Extension ClassLoader（加载 `java.ext.dirs` 和 `jre/lib/ext` 中的类）
  - System ClassLoader（如：Application ClassLoader，加载程序中的自定义类）
- 不同的类加载器之间的关系是「包含关系」

**自定义类加载器的作用：**

- 隔离加载类
- 修改类加载的方式
- 扩展加载源
- 防止源码泄露



### 双亲委派

- 一种任务委派模式，把请求交给父类处理
- JVM 对 Class 文件采用的是「按需加载」的加载方式，而在加载时就会使用双亲委派机制

**工作原理：**

- 如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是会把这个请求委托给父类的加载器去执行
- 如果父类加载器还存在其父类加载器，则会进一步向上委托，以此递归，请求最终会到达顶层的启动类加载器
- 如果父类加载器可以完成类加载任务，就返回成功，倘若无法完成才会让子加载器尝试自己加载

**双亲委派的优势：**

- 可以避免类重复加载
- 可以保护程序安全，防止核心 API 被随意篡改（沙箱安全机制）



### 类的主动/被动使用

**JVM 中两个 Class 对象是否为同一个类的两个必要条件：**

- 类的完整类名必须一致，包括包名
- 加载这个类的 ClassLoader 实例对象必须相同
- 因此，即使两个类对象来源于同一个 Class 文件，被同一个虚拟机加载，但是只要加载它们的 ClassLoader 实例不一样，那么这两个对象就不相等

**类加载器的引用：**

- JVM 必须知道一个类是由启动加载器加载的还是由用户加载器加载的
- 如果一个类是由用户加载器加载的，那么 JVM 会将这个类加载器的一个「引用」作为类型信息的一部分「保存在方法区中」
- 当解析到一个类到另一个类的引用的时候，JVM 需要保证这两个类的加载器是相同的

**主动使用类（7）：**

- 创建类的实例
- 访问某个类或接口的静态变量，或者对该静态变量赋值
- 调用类的静态方法
- 反射
- 初始化一个类的子类
- JVM 启动时被标明为启动类的类
- `java.lang.invoke.MethodHandle` 实例的解析结果

注：除了以上 7 中情况，其他使用类的方式都被看作是对类的「被动使用」，都不会导致「类的初始化」



## 对象创建

### 创建方式

> 五种创建方式

|                方式                |       说明       |
| :--------------------------------: | :--------------: |
|           使用new关键字            |  调用了构造函数  |
|     使用Class的newInstance方法     |  调用了构造函数  |
| 使用Constructor类的newInstance方法 |  调用了构造函数  |
|           使用clone方法            | 没有调用构造函数 |
|            使用反序列化            | 没有调用构造函数 |

### 分配内存

> Java 堆是否规整是由所采用的垃圾收集器是否带有压缩整理功能决定的

**指针碰撞：**

- 前提：Java 堆内存是规整的，所有已用的空间都是紧挨着的
- 分配内存时将位于中间的指针指示器向空闲的内存移动一段与对象大小相等的距离，这样就可以完成内存分配

**空闲列表：**

- 前提：Java 堆内存不是规整的，需要由虚拟机维护一个列表来记录哪些内存是可用的
- 分配内存时从列表中查询到足够大的内存就分配给对象，分配后更新列表
