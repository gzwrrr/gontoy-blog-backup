---
title: "JVM 堆"
shortTitle: "C-JVM 堆"
description: "JVM 堆"
icon: ""
author: 
  name: gzw
  url: 
  email: 1627121193@qq.com
isOriginal: false
date: 2022-06-11
category: 
- "java"
- "JVM"
- "虚拟机"
tag:
- "java"
- "JVM"
- "虚拟机"
sticky: 1
star: false
article: true
timeline: true
dir:
  text: "JVM 堆"
  icon: ""
  collapsible: true
  index: true
  comment: true
headerDepth: 3
index: true
order: 2
copy:
  triggerWords: 100
  disableCopy: false
  disableSelection: false
feed:
  title: "JVM 堆"
  description: "JVM 堆"
  author:
    name: gzw
    email: 1627121193@qq.com
---





# JVM 堆





[[toc]]





## 概述

一个 JVM 实例只存在一个「堆内存」，堆也是 Java 内存管理的核心区域

Java 堆区在 JVM 启动时即被创建，此时空间大小也就确定了，这是 JVM 管理的最大的一块内存空间（内存大小是可以调节的）

堆可以处于物理上的「不连续」的内存空间，但在「逻辑上」应该被视为「连续的」

所有的线程共享 Java 堆，在这里还可以划分「线程私有」的「缓冲区」（TLAB）

几乎所有的「对象实例」以及「数组」运行时都应该分配在堆上

数组和对象可能永远不会存储在栈上，因为栈帧中保存的是引用，这个引用是指向堆的

在方法结束后，堆中的对象不会被立刻移除，而是在之后的垃圾回收时移除；而堆是 GC 执行垃圾回收的重点区域



## 内存细分

现代垃圾收集器（GC）大部分都基于「分代收集理论」设计，堆空间可以细分为：

Java 7 之前堆内存逻辑上分为三部分：新生代（又分为伊甸园区和存活区） + 老年代 + 永久代（这个在方法区）

Java 8 之后堆内存逻辑上分为三部分：新生代（又分为伊甸园区和存活区） + 老年代 + 元空间（这个在方法区）

新生代中实际的内存应该是伊甸园区加上两个存活区中的其中一个（因为存活区是基于复制的，所以其中一个必须为空，其中的内存不能使用）

【内存参数设置】

可以通过 `-Xms` 指令设置堆空间的起始内存，等价于 `-XX:InitialHeapSize`

可以通过 `-Xmx` 指令设置堆空间的最大内存，等价于 `-XX:MaxHeapSize`

一旦堆区中的内存大小超过 `-Xmx` 所指定的最大内存时，就会抛出 `OutOfMemoryError` 异常，即 OOM

通常设置时会将 `-Xmx` 和 `-Xms` 两个参数配置相同的值，目的是为了能够在垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能



## 年轻代与老年代

存储在 JVM 的 Java 对象可以被划分为两类：

- 生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速
- 生命周期非常长，极端情况下可以与 JVM 的生命周期保持一致

年轻代中又可以划分为三个空间：

1. 伊甸园空间
2. Survivor0（也称为 from 区）
3. Survivor1（也称为 to 区）

注：两个存活区的大小是一样的

配置新生代与老年代在堆结构的占比：默认 `-XX:NewRatio=2`，表示新生代占 1，老年代占 2

默认情况下，新生区中的伊甸园区占 8 份，两个存活区各占 1 份，可以通过 `-XX:SurvivorRatio` 调整这个比例（此处需要使用 `-XX:-UseAdaptiveSizePolicy` 关闭自适应的内存分配策略）

绝大部分的 Java 对象的「销毁」都在「新生代」中进行，可以使用  `-Xmn` 来设置新生代最大内存大小（这个参数一般使用默认值就行）

【垃圾回收】

当伊甸园中的空间耗尽时，会进行 `YGC/MinorGC` 垃圾回收，没有引用的对象会被回收，被引用的对象 `age` 会增加进入存活区；下一轮垃圾回收时，同样也是上述过程，但是此时存活的对象需要移向第二块存活区，也就是说存活区必须始终有一块是空的

当一个对象的 `age` 大于 15 时会晋升进入老年代，此后不需要再关注 `age`，何时进入老年代可以使用 `-XX:MaxTenuringThreashold=<N>`（参数默认是 15），进入了老年代中的对象一般都很难再被垃圾回收 

此处需要特别注意，上述提到的过程，只有当伊甸园区的空间耗尽时才会进行 GC，但是当存活区空间耗尽时并不会触发 GC，此时的回收逻辑是，等待伊甸园区再次空间耗尽，然后连同存活区一起进行 GC，即存活区是「被动回收」的，此时清除哪些对象也有特定规则（`age` 未到达 15 也有可能直接进入老年代，甚至一创建就进入老年代也是有可能的）

总结：GC 频繁发生在新生区，很少发生在养老区，几乎不发生在永久区；存活区是采用「复制后交换」的方式交替进行的，必须始终保持有一个存活区是空的，且当存活区满时只能被动进行 GC

【老年代 GC】

老年代 Major GC/FullGC 触发机制：

指发生在老年代的 GC，对象从老年代消失时，我们说 MajorGC 或 FullGC发生了

出现了 MajorGC，经常会伴随至少一次的 MinorGC (但非绝对的，在 Parallel cavenge 收集器的收集策略里就有直接进行 MajorGC 的策略选择过程）

也就是在老年代空间不足时，会先尝试触发 MinorGC。如果之后空间还不足，则触发 MajorGC

MajorGC 的速度一般会比 MinorGC 慢 10 倍以上，STW 的时间更长

如果 MajorGC 后，内存还不足，就报 OOM 了。

【FullFC】

触发条件如下：

1. 调用 `System.gc()` 时，系统建议执行 FullGC，但时不必然执行
2. 老年代空间不足
3. 方法区空间不足
4. 通过 MinorGC 后进入老年代的平均大小大于老年代的可用内存
5. 存活区转移复制对象后整体大小大于存活区的总大小，就会将对象转存到老年代，但是老年代的大小也不能放下这些对象时也会触发

FullGC 是在开发或者调优过程中要尽量避免的，这样线程暂停的时间会短一些

【相关概念】

GC 主要分为两大类：

- 部分收集：
  - MinorGC（新生代收集）
  - MajorGC（老年代收集，目前只有 CMS GC 才有单独收集老年代的行为）
  - MixedGC（混合收集，收集整个新生代以及部分老年代，目前只有 G1 GC 有这种行为）
- 整堆收集：
  - FullGC（收集整个堆和方法区）

调优重点关注的是后两者，因为耗费的时间非常多

注意：很多时候 MajorGC 和 FullGC 会混合使用，需要具体分辨是老年代收集还是整堆收集

【内存分配策略】

针对不同年龄段的对象的分配原则：

- 优先分配到伊甸园区
- 大对象直接分配到老年代（避免程序中出现过多的大对象）
- 长期存活的对象分配到老年代
- 动态对象年龄判断：如果幸存者区中相同年龄的所有对象大小总和大于幸存者区空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 `MaxTenuringThreshold` 中要求的年龄
- 空间分配担保：`-XX:HandlePromotionFailure`，即当 GC 完成后幸存者区还有大量对象存活，那么就需要老年代担保，分出一部分空间

堆空间分代思想

内存分配策略

对象分配内存：TLAB

堆空间的参数设置

探讨堆是否是对象分配的唯一选择



## TLAB 对象分配过程

- 堆区是线程共享区域，任何线程都可以访问到堆中的共享数据
- 对象实例在 JVM 中创建是非常频繁的，并发环境下从堆区划分内存空间是「线程不安全」的
- 为了避免多个线程操作同一个地址，需要使用加锁等机制，但是这会影响分配速度 

**TLAB：**

- 从内存模型而不是垃圾收集的角度，对伊甸园区进行划分，JVM 为每个线程分配一个「私有缓存区域」
- 多线程同时分配内存时，使用 TLAB 可以避免一系列的费县册亨安全问题，同时还能提升内存分配的吞吐量，因此可以把这种分配策略称为「快速分配策略」
- 所有 OpenJDK 衍生出来的 JVM 都使用了 TLAB
- 不是所有的对象实例都能够在 TLAB 中成功分配内存，但是 JVM 会将 TLAB 作为内存分配的首选
- 可以通过选项 `-XX:UseTLAB` 设置是否开启 TLAB 空间（默认是开启的）
- 默认情况下 TLAB 的内存空间是非常下的，仅仅占了伊甸园区空间的 1%，可以通过选项 `-XX:TLABWasteTargetPercent` 设置 TLAB 空间所占用的伊甸园区的百分比大小
- 一旦对象在 TLAB 空间分配内存失败， JVM 就会尝试通过使用加锁机制确保数据操作的原子性，从而直接在伊甸园区中直接分配内存



## 堆常用参数总结

| 序号 | 参数                        | 说明                                                         |
| ---- | --------------------------- | ------------------------------------------------------------ |
| 1    | -XX:+PrintFlagsInitial      | 查看所有的参数的默认初始值                                   |
| 2    | -XX:+PrintFlagsInitial      | 查看所有的参数的默认初始值<br/>                              |
| 3    | -XX:+PrintFlagsFinal        | 查看所有的参数的最终值（可能会存在修改，不再是初始值）<br/>  |
| 4    | -Xms                        | 初始堆空间内存（默认为物理内存的1/64）<br/>                  |
| 5    | -Xmx                        | 最大堆空间内存（默认为物理内存的1/4）<br/>                   |
| 6    | -Xmn                        | 设置新生代的大小。（初始值及最大值）<br/>                    |
| 7    | -XX:NewRatio                | 配置新生代与老年代在堆结构的占比<br/>                        |
| 8    | -XX:SurvivorRatio           | 设置新生代中Eden和S0/S1空间的比例<br/>                       |
| 9    | -XX:MaxTenuringThreshold    | 设置新生代垃圾的最大年龄<br/>                                |
| 10   | -XX:+PrintGCDetails         | 输出详细的GC处理日志<br/>打印gc简要信息：①-Xx：+PrintGC ② - verbose:gc<br/> |
| 11   | -XX:HandlePromotionFalilure | 是否设置空间分配担保                                         |

对于最后一个参数，即空间对象担保：

在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间：

- 如果大于，则此次Minor GC是安全的

- 如果小于，则虚拟机会查看`-XX:HandlePromotionFailure`设置值是否允担保失败。 

- - 如果`HandlePromotionFailure=true`，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小。 

- - - 如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；

- - - 如果小于，则改为进行一次Full GC。

- - 如果`HandlePromotionFailure=false`，则改为进行一次Full Gc。

在 JDK6 Update24 （JDK 7）之后，HandlePromotionFailure 参数不会再影响到虚拟机的空间分配担保策略，观察 OpenJDK 中的源码变化，虽然源码中还定义了 HandlePromotionFailure 参数，但是在代码中已经不会再使用它。JDK6 Update 24 之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行 Minor GC，否则将进行 FullGC。



## 堆的补充 -- 分配优化

堆不是分配对象存储的唯一选择（但是全部分配到堆上在最后被验证是较好的），《深入理解 JVM》中曾表述：

> 随着「JIT 编译期的发展」与「逃逸分析技术」逐渐成熟，「栈上分配」、「标量替换优化技术」将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了

如果经过逃逸分析后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配.。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术

此外，前面提到的基于 OpenJDK 深度定制的 TaoBaoVM，其中创新的 GCIH（GC invisible heap）技术实现 off-heap，将生命周期较长的 Java 对象从 heap 中移至 heap 外，并且 GC 不能管理 GCIH 内部的 Java 对象，以此达到降低 GC 的回收频率和提升 GC 的回收效率的目的。



### 逃逸分析 -- 简介

如何将堆上的对象分配到栈，需要使用逃逸分析手段

这是一种可以有效减少 Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。

通过逃逸分析，Java Hotspot 编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。

逃逸分析的基本行为就是分析对象动态作用域：

- 当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。

- 当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。

**参数设置：**

在JDK 6u23 版本之后，HotSpot中默认就已经开启了逃逸分析

如果使用的是较早的版本，开发人员则可以通过：

- 选项 `-XX:+DoEscapeAnalysis` 显式开启逃逸分析

- 通过选项 `-XX:+PrintEscapeAnalysis` 查看逃逸分析的筛选结果

**结论**：开发中能使用局部变量的，就不要使用在方法外定义



### 逃逸分析 -- 代码优化

使用逃逸分析，编译器可以对代码做如下优化：

1. 「栈上分配」：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会发生逃逸，对象可能是栈上分配的候选，而不是堆上分配

2. 「同步省略」：如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同步

3. 「分离对象或标量替换」：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU 寄存器中

**栈上分配：**

- JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了

- **常见的栈上分配的场景**：在逃逸分析中，已经说明了。分别是给成员变量赋值、方法返回值、实例引用传递

**同步省略：**

- 线程同步的代价是相当高的，同步的后果是降低并发性和性能。

- 在动态编译同步块的时候，JIT 编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫锁消除

**标量替换：**

- 标量（scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量
- 相对的，那些还可以分解的数据叫做聚合量（Aggregate），Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。
- 在 JIT 阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换

**标量替换参数设置：**

- 参数 `-XX:EliminateAllocations`：开启了标量替换（默认打开），允许将对象打散分配到栈上。

- 标量替换参数设置示例：

  ```shell
  -server -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations
  ```

- 这里设置参数如下：

  - 参数`-server`：启动Server模式，因为在server模式下，才可以启用逃逸分析。

  - 参数`-XX:+DoEscapeAnalysis`：启用逃逸分析

  - 参数`-Xmx10m`：指定了堆空间最大为10MB

  - 参数`-XX:+PrintGC`：将打印Gc日志

  - 参数`-XX:+EliminateAllocations`：开启了标量替换（默认打开），允许将对象打散分配在栈上，比如对象拥有id和name两个字段，那么这两个字段将会被视为两个独立的局部变量进行分配



### 逃逸分析 -- 小结

关于逃逸分析的论文在1999年就已经发表了，但直到 JDK1.6 才有实现，而且这项技术到如今也并不是十分成熟

其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。

一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了

虽然这项技术并不十分成熟，但是它也是即时编译器优化技术中一个十分重要的手段

注意到有一些观点，认为通过逃逸分析，JVM 会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于 JVM 设计者的选择。据我所知，Oracle Hotspot JVM 中并未这么做，这一点在逃逸分析相关的文档里已经说明，所以可以明确所有的对象实例都是创建在堆上。

目前很多书籍还是基于 JDK7 以前的版本，JDK 已经发生了很大变化，intern 字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是，intern 字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论：对象实例都是分配在堆上。



## 堆的总结

年轻代是对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。

老年代放置长生命周期的对象，通常都是从 survivor 区域筛选拷贝过来的 Java 对象。当然，也有特殊情况，我们知道普通的对象会被分配在 TLAB 上；如果对象较大，JVM 会试图直接分配在 Eden 其他位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM就会直接分配到老年代。当GC只发生在年轻代中，回收年轻代对象的行为被称为 MinorGC。

当 GC 发生在老年代时则被称为 MajorGc 或者 FullGC。一般的，MinorGC 的发生频率要比 MajorGC 高很多，即老年代中垃圾回收发生的频率将大大低于年轻代。


