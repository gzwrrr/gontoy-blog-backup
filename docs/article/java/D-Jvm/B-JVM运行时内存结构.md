---
title: "JVM 运行时内存结构"
shortTitle: "B-JVM 运行时内存结构"
description: "JVM 运行时内存结构"
icon: ""
author: 
  name: gzw
  url: 
  email: 1627121193@qq.com
isOriginal: false
date: 2022-06-11
category: 
- "java"
- "JVM"
- "虚拟机"
tag:
- "java"
- "JVM"
- "虚拟机"
sticky: 1
star: false
article: true
timeline: true,
dir:
  text: "JVM 运行时内存结构"
  icon: ""
  collapsible: true
  index: true
  comment: true
headerDepth: 3
index: true
order: 2
copy:
  triggerWords: 100
  disableCopy: false
  disableSelection: false
feed:
  title: "JVM 运行时内存结构"
  description: "JVM 运行时内存结构"
  author:
    name: gzw
    email: 1627121193@qq.com
---





# JVM 运行时内存结构



[[toc]]





在 Hotspot JVM 中，每个线程都与操作系统的本地线程直接映射

当一个 Java 线程准备好执行后，操作系统的一个本地线程也同时创建

Java 线程执行终止后，本地线程也会回收

操作系统负责把所有线程安排调度到任何一个可用的 CPU 上

一旦本地线程初始化成功，就会调用 Java 线程中的 `run`  方法



**Hotspot JVM 中的主要线程类型：**

- 虚拟机线程：需要 JVM 到达「安全点」才会出现的（需要保证堆不变化）。这种线程的执行类型包括：
  - stop-the-world 的垃圾收集
  - 线程栈收集
  - 线程挂起
  - 偏向锁撤销
- 周期任务线程：这种线程是时间周期时间的体现（如中断），它们一般用于周期性操作的调度执行
- GC 线程：这种线程对在 JVM 里不同种类的垃圾收集行为提供支持
- 编译线程：这种线程在运行时会将字节码编译成本地代码
- 信号调度线程：这种线程接收信号并发送给 JVM，在它内部通过调用适当的方法进行处理





## 程序计数器

> PC 计数器（Program Counter Register），源于 CPU 的寄存器，可以理解成「游标」

- PC 寄存器用来存储指向下一条指令的地址，即：将要执行的指令代码。之后由执行引擎取下一条指令
- 在内存中是一块很小的内存空间，几乎可以忽略不记，也是运行速度最快的存储区域
- JVM 规范中，每个线程都有自己的程序计数器，即线程私有的，生命周期与线程的生命周期保持一致
- 任何时间，一个线程都只有一个方法在执行，也就是「当前方法」
- 程序计数器会存储当前线程正在执行的 Java 方法的 JVM 指令地址；或者，如果执行的是 native 方法（对应本地方法栈），则是未指定值（undefined）
- 程序控制流的指示器，分治、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个程序计数器来完成
- 字节码解释器工作时就是通过改变这个计数器的值来选择吓一条需要执行的字节码指令
- 程序计数器是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域
- 对于程序计数器而言，不存在异常和垃圾回收的问题





## 方法区

> 常量信息是 Class 文件中常量池部分的内存映射

- 类加载信息
- 运行时常量池信息
- 字符串字面量
- 数字常量



## 虚拟机栈

> 栈是运行时的单位；堆是存储的单位

- 栈解决的是程序运行的问题，即程序如何执行，如何处理数据
- 每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的「栈帧」，对应着一次次的 Java 方法调用，故虚拟机栈是线程私有的
- 生命周期和线程一致
- 主管 Java 程序的运行，保存方法的「局部变量」（8 种基本数据类型、对象的引用地址）、「部分结果」、「方法的调用和返回」
- 虚拟机栈的大小允许「动态」或者「固定不变」

**优点：**

- 栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器
- JVM 对虚拟机栈的操作只有两个：
  - 每个方法执行都伴随着进栈
  - 每个方法执行结束后出战
- 对于栈而言，不存在垃圾回收问题

**可能的异常：**

- StackOverflowError：采用固定大小的虚拟机栈会在容量超出时抛出 StackOverflowError 异常
- OutOfMemoryError：如果虚拟机栈采用的是动态扩展的，并且在尝试扩展时无法申请到足够的内存时，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那么虚拟机就会抛出 OutOfMemoryError 异常（OOM）

**虚拟机参数：**

- `-Xss`：调整虚拟机栈的大小



### 栈帧

**栈的存储单位：**

- 「栈帧」是栈的基本单位
- 在线程上正在执行的「每个方法」都有各自对应的一个「栈帧」
- 「栈帧」是一个内存区块，是一个数据集

**运行原理：**

- 栈的操作只有对栈帧的压栈和出栈
- 在一条活动的线程中，一个时间点上，只有一个活动的栈帧，即当前正在执行的方法的栈帧
- 与当前栈帧对应的方法就是当前方法，定义这个方法的类就是当前类
- 执行引擎运行的所有字节码指令只针对当前栈帧进行操作
- 如果在当前方法中调用了其他方法，对应的新的栈帧会被创建出来，称为新的当前栈
- 不同线程中所包含的栈帧是不允许存在互相引用的，即不可以引用另外一个线程的栈帧
- 正常的函数返回或者抛出异常都会导致栈帧被弹出

**栈帧的内部结构：**

- 局部变量表
- 操作数栈（表达式栈）
- 动态链接（指向运行时常量池的方法引用）
- 方法返回地址（正常退出或异常退出的定义）
- 附加信息



### 局部变量表

> 又称为「局部变量数组」或「本地变量表」

- 一个数字数组，主要用于存储「方法参数」和定义在方法内的「局部变量」，类型包括：8op3
  - 各类基本数据类型
  - 对象引用
  - 返回值类型
- 局部变量表是线程私有的，不存在数据安全问题
- 局部变量表所需的容量大小是在「编译器」确定下来的，保存在方法的 Code 属性的 `maximum local variables` 数据项中
- 方法运行期间是不会更改局部变量表的大小的
- 在栈帧中，与性能调优最密切的就是局部变量表
- 局部变量表中的变量也是重要的垃圾回收节点，只要被局部变量表中「直接」或「间接引用」的对象都不会被回收

**局部变量表的 slot：**

- 参数值总是存放在局部变量数组的 index=0 的位置，到数组长度 -1 的索引结束
- 局部变量表的最基本存储单元是 slot
- 局部变量表中存放编译器可知的各种「基本数据类型」、引用类型、返回值类型的变量
- 在局部变量表中，32 位以内的类型只占用一个 slot，64 位的类型占用两个 slot
  - byte、short、char、boolean 在存储前都被转换成 int
  - long、double 占据两个 slot

- JVM 会为局部变量表中的每一个 slot 分配一个「访问索引」。通过这个索引可以访问到对应的局部变量值
- 当一个实例方法被调用时，他的方法参数和方法体内部定义的局部变量将「按照顺序被复制」到局部变量表中的每一个 slot 上
- 如果需要访问局部变量表中的一个 64 位的局部变量值时，只需要使用一个索引即可（起始索引）
- 如果当前帧是由「构造方法」或者「实例方法」创建的，那么该对象引用 this 将会存储在 「index 为 0 的 slot 处」，其余的参数按照参数表顺序继续排列；因此静态代码块中不允许使用 this
- 栈帧中的局部变量表中的 slot 是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后声明的新的局部变量就可能复用过期的局部变量的槽位，从而达到节省资源的目的



### 操作数栈

- 在方法执行过程中，根据字节码指令，可能会往栈中写入数据和提取数，例如执行复制、交换、求和等操作
- 主要用于保存计算过程中的「中间结果」，同时作为计算过程中变量的「临时存储空间」
- 操作数栈是 JVM 执行引擎的一个工作区，当一个新的栈帧创建出来后，其操作数栈是空的
- 每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需要的最大深度在编译器就定义好了，保存在方法的 Code 属性中，为 max_stack 的值
- 操作数栈中的任何一个元可以是任意的 Java 数据类型
  - 32 位的类型占用一个栈单位深度
  - 64 位的类型占用两个栈单位深度
- 操作数栈并非采用访问索引的方式进行数据访问，而是只能通过标准的入栈出栈操作来完成一次数据访问
- 如果被调用的方法带有「返回值」，那么其返回值会被压入当前栈帧的「操作数栈」中，并更新 PC 寄存器中下一条需要执行的字节码指令
- 操作数栈中的元素的「数据类型」必须与「字节码指令的序列」严格匹配，这由编译器在编译期间进行验证，同时在类加载阶段的类校验阶段的数据流分析阶段再次验证
- JVM 的解释引擎是基于栈的执行引擎，其中的栈指的就是「操作数栈」



### 动态链接

> 或称为：运行时常量池的方法引用

- 每一个栈帧内部都包含一个指向「运行时常量池」中「该栈帧所属方法的引用」，包含整个引用的目的就是支持当前方法的代码能够「动态链接」
- 在 Java 源文件被编译到字节码文件时，所有的「变量」和「方法引用」都作为「符号引用」保存在 Class 文件的常量池里，当建立动态链接后，就将「符号引用」转化为调用方法的直接引用



### 方法的调用

> 将符号引用转化为调用方法的直接引用与方法的「绑定机制」有关

**静态链接：**当一个字节码文件被转载进 JVM 内部时，如果被调用的目标方法在编译期可知，且运行时保持不变，那么这种情况下就将转换为直接引用的过程称为「静态链接」

**动态链接：**被调用的方法在编译期无法确定下来，只能在程序运行期间转换为直接引用，所以这种转换过程具有动态性，称之为「动态链接」

**绑定：**绑定是一个「字段」、「方法」、「类」在符号引用被替换为直接引用的过程，这个过程仅仅发生一次

- 早期绑定：指被调用的「目标方法」在编译期可知，可以直接将方法与所属的类型进行绑定，这样就可以明确被调用的方法是哪一个，即可以使用「静态链接」
- 晚期绑定：被调用的方法在编译期无法确定下来，只能根据运行期实际的类型绑定相关的方法，即使用「动态链接」

**虚方法和非虚方法：**

- 如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的，那么这样的方法就称为非虚方法；静态方法、私有方法、final 方法、实例构造器、父类方法都是非虚方法；除此之外的方法称为虚方法
- 虚拟机中提供了一下几条方法调用指令：
  - `invokestatic`：调用静态方法，解析阶段确定唯一方法版本
  - `invokespecial`：调用 `<init>` 方法、私有方法以及父类方法，解析阶段确定唯一版本
  - `invokevirtual`：调用所有虚方法
  - `invokeinterface`：调用接口方法
  - `invokeddynamic`：动态解析出需要调用的方法后执行（Java 7 之后才增加的指令）

- 上述前四条指令固化在虚拟机内部，方法的调用执行不可以认为干预，其中前两条指令调用的方法称为非虚方法，其余的（final 修饰的除外）称为虚方法；最后一条指令则支持用户确定方法版本

**方法重写的本质：**

- 找到操作数栈顶的第一个元素所执行的对象的「实际类型」，记作 C
- 如果在过程结束时，不通过类型 C 中找到与常量中的描述符合的简单名称相符的方法，就会进行「访问权限校验」，如果通过则返回这个方法的直接引用，找不到就会抛出 `IllegaAccessError` 异常
- 在当前类中找不到则会按照继承关系从下往上依次对 C 的各个父类进行上述步骤的搜索和验证
- 如果始终都没有找到合适的方法，则会抛出 `AbstractMethodError` 异常

**虚方法表：**

- 在面向对象编程中，会频繁地使用到动态分配（`invokeddynamic`），如果每次分派过程中都需要重新在类的方法元数据中搜索合适的目标，那么就会影响执行效率，为了提高性能，JVM 采用在「方法区」建立一个虚方法表来实现（非虚方法不会在其中出现），内部是使用「索引表」来代替查找
- 每个类中都有一个虚方法表，表中存放着各个方法的实际入口
- 虚方法表的创建实际是，在类加载的「链接阶段」被创建并初始化的，类变量初始值准备完成后，JVM 会把该类的「方法表」也初始化完毕

**方法返回地址：**

- 存放调用该方法的 PC 寄存器的值（即下一条需要执行的指令的地址）
- 一个方法的结束有两种方式：
  - 正常执行完成
  - 出现未处理的异常，非正常退出
- 但是无论通过哪种方法退出，之后都会返回到该方法被调用的位置。正常退出时，调用者的 PC 寄存器的值作为返回地址；通过异常退出，返回地址是要通过「异常处理表」来确定，栈帧中一般不会保存这部分信息
  - 正常完成出口：执行引擎遇到任意一个方法返回的字节码指令（return），就会有返回值传递给上层的方法调用者
  - 异常完成出口：在方法执行过程中遇到了异常，并且这个异常没有在方法内进行处理，也即只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出
- 一个方法在正常调用完成之后究竟需要使用哪一个返回指令还需要根据方法返回值的「实际数据类型」而定
- 在字节码指令中，返回指令包含 `ireturn` （当返回值是 `boolean`、`byte`、`char`、`short`、`int`）、`lreturn`、`freturn`、`dreturn`、`areturn`。另外还有一个 `return` 指令供声明为 void 的方法、实例初始化方法、类和接口的初始方法使用
- 本质上来说，方法的退出就是当前「栈帧出栈」的过程。此时需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈的操作数栈、设置 PC 寄存器值等，这样才能让调用者方法继续执行下去；正常完成和异常完成的区别在于：通过异常完成退出的方法不会给他的上层调用者产生任何的返回值

**附加信息：**

栈帧中还允许携带与 Java 虚拟机实现相关的一些附加信息，例如对程序调试提供支持的信息



### 常见面试题

1. 举例栈溢出的情况？ —— OOM，通过 -Xss 设置栈的大小
2. 调整栈大小，就能保证不出现栈溢出？—— 不能保证一定不溢出，例如对于死循环只能延缓溢出的时间
3. 分配的栈内存越大越好吗？—— 不是，可能会导致其他结构的内存空间减少，导致性能下降
4. 垃圾回收是否涉及到虚拟机栈？—— 本地方法栈和虚拟机栈都不会涉及到虚拟机栈
5. 方法中定义的局部变量是否线程安全？—— 不一定，如果是多线程或者方法参数逃逸则可能线程不安全，即如果变量能在内部消亡则是安全的





## 本地方法栈

【简介】----------------------------------------------------------------------------------------------------------------------------------------------------------------------

一个「本地方法」就是一个 Java 调用非 Java 代码的接口（使用 native 关键字修饰）

本地方法的实现由「非 Java 语言」实现，比如 C，但是这个特征不是  Java 特有的，例如 C++ 中也可以调用 C 的函数

在定义一个本地方法时，并不提供实现体，类似定义 Java 中的接口，因为其实现体式由其他语言实现的

需要提高程序性能时就可以考虑使用本地方法；或者需要与 Java 的外部环境交互时也是使用本地方法（本地方法存在的主要原因）

但是目前本地方法已经很少使用了，除非是要编写与硬件相关的应用

【相关】----------------------------------------------------------------------------------------------------------------------------------------------------------------------

本地方法栈也是「线程私有的」，允许被实现成固定或者可动态扩展的内存大小（在内存溢出方面和虚拟机栈一样）

本地方法的具体做法就是使用 native 关键字表示本地方法，这样就会将该方法登记到本地方法栈中，之后会在 Execution Engine 执行时加载本地方法

【进阶】----------------------------------------------------------------------------------------------------------------------------------------------------------------------

当某个线程调用一个本地方法时，它就进入到了一个全新的不受虚拟机限制的世界，此时它与虚拟机拥有相同的全新啊

本地方法可以通过本地方法接口来访问「虚拟机内部的运行时数据区」，甚至可以直接使用本地处理器中的「寄存器」，也可以直接从本地内存的堆中分配任意数量的「内存」

但是注意，并不是所有 JVM 都支持本地方法。不过在 Hotspot JVM 中是直接将本地方法栈和虚拟机栈合二为一了





