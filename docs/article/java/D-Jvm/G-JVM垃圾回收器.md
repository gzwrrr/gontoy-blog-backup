---
title: "JVM 垃圾回收器"
shortTitle: "G-JVM 垃圾回收器"
description: "JVM 垃圾回收器"
icon: ""
author: 
  name: gzw
  url: 
  email: 1627121193@qq.com
isOriginal: false
date: 2022-06-11
category: 
- "java"
- "JVM"
- "虚拟机"
tag:
- "java"
- "JVM"
- "虚拟机"
sticky: 1
star: false
article: true
timeline: true
dir:
  text: "JVM 垃圾回收器"
  icon: ""
  collapsible: true
  index: true
  comment: true
headerDepth: 3
index: true
order: 2
copy:
  triggerWords: 100
  disableCopy: false
  disableSelection: false
feed:
  title: "JVM 垃圾回收器"
  description: "JVM 垃圾回收器"
  author:
    name: gzw
    email: 1627121193@qq.com
---





# JVM 垃圾收集器

> 什么是垃圾：运行程序中没有任何「指针」指向的对象
>
> 为什么进行垃圾回收：不进行内存管理会造成内存泄露、内存溢出

经典三问：

1. 那些内存需要回收？
2. 什么时候回收？
3. 如何回收？

常见的两种标记算法：

1. 引用计数算法
2. 可达性分析算法

常见的三种回收算法：

1. 标记-清除算法
2. 标记-压缩算法
3. 复制算法

垃圾回收步骤：

1. 确定内存中存活和死亡的对象
2. 执行垃圾回收，释放占用的内存空间





## 垃圾回收算法

标记阶段：

1. 引用计数算法
2. 可达性分析算法

清除阶段：

1. 标记-清除算法
2. 标记-压缩算法
3. 复制算法



### 引用计数

判断对象存活：一般有引用计数和可达性分析算法。当一个对象没有被任何对象引用时就不是存活的

引用计数就是对每个对象保存一个整型的引用计数器属性，用于记录对象被引用的次数

当对象 A 的引用计数器的值为 0 时表示该对象不可能再被使用，可以进行垃圾回收

优点：

1. 实现简单
2. 垃圾对象便于识别
3. 判定效率高，回收没有延迟性

缺点：

1. 需要单独的字段存储计数器，增加了存储空间的开销
2. 每次赋值都需要更新计数器，伴随加减操作，增加了时间开销
3. 无法处理「循环引用」的问题，这点非常严重，导致了 Java 的垃圾回收器中没有使用这类算法





### 可达性分析算法

> 也称为：跟搜索算法、追踪性垃圾收集

可以有效地解决引用计算算法中的循环引用问题，是较为常用的算法

**基本步骤：**

1. 以「根对象（GC Roots）」为起始点，按照从上到下的方式搜索被根对象集合连接的目标对象是否可达
2. 内存中的「存活对象」都会被根对象集合直接或者间接连接着，搜索时走过的路径称为「引用链」
3. 如果目标对象没有任何引用链相连就是不可达的，可以标记为垃圾对象

**根对象包括（非堆区的对象：栈、方法区、虚拟机、锁住的对象）：**

1. 虚拟机栈中引用的对象：比如各个线程调用的方法中使用到的参数、局部变量等
2. 本地方法栈内 JNI 引用的对象
3. 方法区中类静态属性引用的对象
4. 方法区中常量引用的对象：比如字符串常量池中引用的对象
5. 所有被同步锁 synchronizeed 持有的对象
6. 虚拟机内部的应用：比如基本数据类型对应的 Class 对象，一些常驻的异常对象，系统类加载器
7. 反应虚拟机内部情况的 JMXBean、JVMTI 中注册的回调、本地代码缓存等

**判断根对象的小技巧：保存了堆内存中的对象，但是自身又不再堆内存里面，那么大概率是一个根对象**

**注意点：**

1. 如果需要使用可达性分析算法，那么分析工作必须在一个能够保障「一致性」的快照进行，如果不能满足这一点，那么分析结果的准确性就无法保证
2. 这一点也导致了 GC 时必须「Stop The World」，即使是在号称（几乎）不会发生停顿的 CMS 收集器中，枚举根节点时也是必须要停顿的





### Finalization 机制

1. Java 提供了对象终止机制来允许开发人员提供对象被销毁之前的「自定义销毁逻辑」
2. 垃圾回收前，总会先调用这个对象的 `finalize()` 方法
3. `finalize()` 方法允许被子类重写，用于在对象被回收时进行资源释放。通常用于关闭文件、套接字、数据库连接等

注意点：不用调用某个对象的 `finalize()` 方法，应该交给垃圾回收机制调用，因为：

1. 在 `finalize()` 时可能导致对象复活
2. `finalize()`  方法的执行时间没有保障，完全由 GC 线程决定，极端情况下，如果不发生 GC，则 `finalize()` 方法将没有执行机会
3. 一个糟糕的 `finalize()` 重写会严重影响 GC 的性能

由于 `finalize()` 方法的存在，虚拟机中的对象一般处于三种可能的状态：

1. 可触及的：从跟节点出发，可以到达这个对象
2. 可复活的：对象的所有引用都被释放，但是对象有可能在 `finalize()` 方法中复活
3. 不可触及的：对象的 `finalize()` 方法被调用，并且没有复活，那么就会进入不可触及状态，该状态下对象不可能被复活，因为 `finalize()` 方法只会被调用一次。只有在对象不可触及时才可以被回收

判定一个对象是否可以回收，至少要经历两次标记：

1. 如果该对象没有引用链，进行第一次标记
2. 进行筛选：判断此对象是否有必要执行 `finalize()` 方法：
   1. 如果该对象没有重写 `finalize()` 方法，或者 `finalize()` 已经被虚拟机调用过，那么就视为没有必要执行，被判定为不可触及的
   2. 如果对象重写了 `finalize()` ，并且还没有执行，那么该对象会被插入到 F-Queue 队列中，由一个虚拟机自动创建的、低优先级的 Finalizer 线程触发其 `finalize()` 方法
   3. `finalize()`  方法时对象复活的最后机会，稍后 GC 会对 F-Queue 队列中的对象进行「二次标记」。如果该对象在 `finalize()` 中与引用链上的任意对象连接，那么在第二次标记时该对象就会被移出即将回收的集合中。之后对象会再次出现没有引用存在的情况，这个情况下，`finalize()` 方法不会被再次执行，对象会直接变成不可触及状态，也就是说，一个对象的 `finalize()` 方法只会被调用一次





### 标记-清除算法

执行过程：

1. 当堆中的有效内存被耗尽时，会停止整个程序（STW），然后进行标记和清除工作
2. 标记就是收集器从引用根节点触发，标记所有被引用过的对象，一般是在对象的 Header 对象头中记录为可达对象
3. 清除就是收集器对堆内存从头到尾进行线性的遍历，如果发现否个对象没有标记为可达对象，就将其进行回收

缺点：

1. 效率不高
2. GC 时需要 STW
3. 清理出来的空闲内存不是连续的，还需要维护一个空闲列表

注意：这里的清除不是真的置空，而是把需要清除的对象地址保存在空闲地址列表里，新对象需要加载时就判断空间是否足够





### 复制算法

为了解决标记-清除算法效率低的问题，出现了复制算法

复制算法的核心思想：

1. 内存空间分为两块，每次只是用其中的一块
2. 在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象
3. 交换两个内存块的角色，最后完成垃圾回收

优点：

1. 没有标记和清除过程，实现简单，运行高效
2. 复制后能够保证空间连续，不会出现碎片

缺点：

1. 需要两倍的内存空间
2. 对于 G1 这种芬超成为大量 region 的 GC，复制而不是移动也就意味着 GC 时需要为胡 region 之间对象的引用关系，内存占用和时间开销都不小

注意：存活对象非常多时复制算法效率也比较低





### 标记-压缩算法

老年代中的对象一般都是存活的，使用复制算法不理想，出现了标记-压缩算法

标记压缩算法执行过程：

1. 第一阶段和标记-清除算法一样，即标记所有被引用的对象
2. 第二阶段将所有存活对象压缩到内存的一端，并按顺序排放
3. 清理边界外的所有空间

当需要给新对象分配内存时，JVM 只需要持有一个内存的起始地址即可，这样比维护一个空闲列表减小了许多开销（相比于标记-清除算法）

优点：

1. 消除了标记-清除算法内存区域分散的缺点
2. 消除了复制算法内存减半的代价

缺点：

1. 效率低于复制算法
2. 移动对象时，如果对象被其他对象引用，还需要调整引用的地址（Java 中不是用句柄池，而是直接引用）
3. 移动过程中，需要 STW





### 分代收集算法

> 不同的对象的生命周期不一致，针对不同生命周期的对象可以采取不同的收集方式，提高回收效率

目前几乎所有 GC 都是采用分代收集，一般分为年轻代和老年代：

1. 年轻代垃圾收集比较频繁，适合使用复制算法
2. 老年代对象生命周期长，一般使用标记-清除和标记-整理的混合实现

HotSpot 虚拟机中的 CMS 收集器是基于标记-清除算法实现的，对于对象的回收效率很高。对于碎片问题，CMS 采用基于 Mark-Compact 算法的 Serial Old 回收器作为补偿措施，即当内存回收不佳，将采用 Serial Old 执行 Full GC 对老年代内存进行整理





### 增量收集算法

如果一次性将所有的垃圾进行处理，会造成长时间停顿，那么可以让垃圾收集线程和应用程序线程交替执行，每次垃圾收集线程只收集一片区域的内存空间

增量收集算法的基础仍是标记-清除算法和复制算法，增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理、复制的工作

缺点：线程上下文切换开销大，会使得垃圾回收的总体成本上升，造成系统吞吐量下降





### 分区算法

> 主要针对于 G1 垃圾收集器

将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区域，减少一次 GC 产生的停顿。每一个小区间都独立使用，独立回收，好处是能够控制一次回收多少个小区间





## 垃圾收集相关知识

### System.gc()

通过 `System.gc()` 或者 `Runtime.getRuntime.gc()` 的调用，会显式触发 Full GC，同时对年轻代和老年代进行回收

但是注意，调用后无法保证对垃圾收集器的调用，换句话说，调用后只是希望 JVM 进行一次 Full GC





### 内存溢出与内存泄露

内存溢出（OOM）式相对于内存泄露来说的，OOM 是因为没了有空闲空间，并且垃圾回收器也无法提供更多的内存，堆内存不足的原因主要有：

1. 虚拟机的堆内存设置不够
2. 代码中创建了大量对象，并且长时间不能被垃圾收集器回收

内存泄漏是指对象不会被程序用到，但是 GC 又不能将他们回收的情况。对象生命周期过长也会造成宽泛意义上的内存泄露，例如单例模式对象不会被回收

一些以提供了 `close()` 方法的资源未关闭也可能导致不能被回收导致内存泄露，比如数据库连接





### Stop The World

程序 GC 时会产生停顿，因为回收算法的分析工作必须在一个必须能保证一致性的快照中进行，即不停顿就不能保证一致性

被 STW 中断的应用程序会在 GC 之后恢复

STW 与采用哪款 GC 无关，即 STW 是一定会发生的，但是不同的垃圾收集器 STW 时间会有差异

注意：开发中不要显式调用 `System.gc()`，因为会发生 STW





### 垃圾回收的并行与并发

> 此处的概念针对于垃圾回收线程

并行：指多条垃圾回收线程并行工作，此时用户线程处于等待状态，此类垃圾回收器有：

1. ParNew
2. Parallel
3. Scavenge
4. Parallel Old

串行：垃圾回收器单线程执行

并发：指用户线程与垃圾收集线程同时执行，但是不是并行，而是交替执行，此时垃圾回收线程在执行时不会停顿用户程序的运行，此类垃圾回收器有：

1. CMS
2. G1





### 安全点与安全区域

程序执行时并非所有地方都可以停止进行 GC，只有特定位置才能停顿，这些位置称为安全点（SafePoint）

安全点的选择很重要，太少会导致 GC 等待时间过长，太多可能导致运行时出现性能下降的问题

通常选择一些执行时间较长的执行作为安全点，比如方法调用、循环跳转、异常跳转等

在 GC 发生时有两种中断方式：

1. 抢占式中断（已经不使用）：中断所有线程，如果还有线程不在安全点，恢复线程运行，再到安全点停止
2. 主动式中断：设置一个中断标志，各个线程运行到安全点时主动轮询这个标志，如果中断标志为真，则将自己中断挂起

安全区域（SafeRegion）是指一段代码片段中，对象的引用关系不会发生改变，在这个区域中的任何位置开始 GC 都是安全的，例如线程处于 Sleep 状态或者 Blocked 状态





### 引用

1. 强引用：强引用对象永远不会被回收
2. 软引用：内存不足时进行回收
3. 弱引用：软引用的对象只能存活到下一次垃圾回收之前
4. 虚引用：是否有虚引用都不影响对象回收，虚引用的目的就是能在这个对象被垃圾回收器回收时收到一个系统通知





## 垃圾收集器

按垃圾回收的线程数，可以分为：

1. 串行垃圾收集器
2. 并行垃圾收集器

按工作模式，可以分为：

1. 并发式垃圾回收器：回收线程与用户线程交替执行
2. 独占式垃圾回收器：回收时用户线程停止（STW）

按碎片处理方式，可以分为：

1. 压缩式垃圾回收器：会清理碎片，之后分配对象采用指针碰撞
2. 非压缩式垃圾回收器：不会清理碎片，之后分配对象采用空闲列表

按工作内存区间，可以分为：

1. 年轻代垃圾回收器
2. 老年代垃圾回收器





### 评估GC 的性能指标

1. 吞吐量：用户代码运行时间占总时间的比例
2. 垃圾收集开销：垃圾收集运行时间占总时间的比例
3. 暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间
4. 收集频率：相对于应用程序的执行，收集操作发生的频率
5. 内存占用：Java 堆区所占的内存大小
6. 快速：一个对象从诞生到被回收所经历的时间

重点关注：吞吐量、暂停时间（最重要）

现在的标准一般是：在最大吞吐量优先的情况下，降低停顿时间





### 垃圾收集器发展史

1. 1999：第一款串行式收集器 Serial GC；ParNew GC 是 Serial 的多线程版本
2. 2002：Parallel GC（JDK 6 之后的默认收集器） 和 Concurrent Mark Sweep GC（CMS）发布
3. 2012：G1 发布，2017 年 JDK 9 中 G1 代替 CMS 成为默认垃圾回收器，2018 年 G1 并行性改善
4. 2018：JDK 11 引入 Epsilon GC，又称为「No-op」无操作回收器；同时引入 ZGC 可伸缩的低延迟垃圾回收器
5. 2019：JDK 12 增强 G1，同时引入了 Shenandoah GC 低停顿时间 GC
6. 2019：JDK 13 增强 ZGC
7. 2020：JDK 14 删除 CMS 垃圾回收器，扩展 ZGC 在 macOS 和 Windows 上的而应用





### 回收器分类

![image-20230511163504305](https://my-photos-1.oss-cn-hangzhou.aliyuncs.com/markdown//jvm/20230513/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%88%86%E7%B1%BB.png)

**经典回收器：**

串行回收器：

1. Serial（年轻代）
2. Serial Old（又称为：MSC，老年代）

并行回收器：

1. ParNew（年轻代）
2. Parallel Scavenge（年轻代）
3. Parallel Old（老年代）

并发回收器：

1. CMS（老年代、低延时）
2. G1（年轻代和老年代）

**一般组合如下：**

1. Serial + Serial Old：一般用于客户端（单核 CPU）
2. ParNew + CMS：JDK 8 之前可以使用，JDK 9 之后不建议使用
3. Parallel Scavenge + Parallel Old： JDK 8 默认收集器，吞吐量优先，可以自适应调节，和上面两个组合相比底层实现不一致，主要用于交互少的后台运算，高吞吐量适用于服务端
4. G1：JDK 9 之后的默认垃圾收集器，官方称为全功能收集器，在停顿时间可控情况下，尽可能提高吞吐量

**一般来说：**

1. 最小化使用内存和并行开销，用 Serial GC
2. 最小化 GC 的中断时间，用 CMS GC
3. 最大化应用程序的吞吐量，用 Parallel GC

**新生代 GC：**

1. Epsilon GC：无操作 GC
2. Shenandoah GC（RedHat）：低停顿 GC，但是吞吐量下降
3. ZGC：可伸缩 GC，性能很高，未来可能替代 G1

**其他：**

1. AliGC：性能比 G1 稍好一些
2. Zing：低延迟 GC





### G1 垃圾回收器

1. G1 把堆内存分割成很多 Region，这些 Region 逻辑上连续，物理上不连续，以此避免在整个堆区进行垃圾收集
2. G1 会跟踪各个垃圾堆积的价值大小（回收获得的空间大小以及需要的时间），会在后台维护一个优先列表，每次根据允许的回收时间，优先回收最大价值的 Region
3. 由于这种方式侧重于回收垃圾最大量的 Region，所以才称为 G1 垃圾有限（Garbage First）
4. G1 时面向服务端的垃圾收集器，主要针对配备多核 CPU 以及大容量内存的机器





#### G1 的特点

1. 分代收集：逻辑上或分为多个 Region，物理上不要求连续
2. 空间整合：内存回收以 Region 为单位，Region 之间时复制算法，但是整体上可以看作是标记-压缩算法，能够避免内存碎片，有利于程序长时间运行
3. 可预测的停顿模型：能够指定垃圾收集不得超过多少毫秒
4. 并行性：G1 在回收期间，可以有多个 GC 线程同时工作，有效利用多核计算能力
5. 并发性：G1 拥有与程序交替执行的能力，一般不会在整个回收阶段发生完全阻塞应用程序的情况

**注意：**G1 相较于 CMS 没有压倒性的优势，G1 在大内存应用上比较能够发挥优势，平衡点在 6 ~ 8 GB 左右，在小内存应用上 CMS 的表现大概率会好于 G1

<br/>

一般使用 G1 时考虑到调优要进行三步：

1. 开启 G1 垃圾收集器（JDK 9 默认）
2. 设置堆的最大内存
3. 设置最大停顿时间

<br/>

G1 中提供了三种垃圾回收模式：

1. Young GC
2. Mixed GC
3. Full GC





#### G1 的使用场景

1. 面向服务端应用，针对具有大内存、多处理器的机器
2. 最主要的应用是需要低 GC 延迟，并具有大堆的应用程序（比如堆大小为 6 GB 以上，可预测的停顿时间低于 500 ms）
3. 可以用于替代 CMS 收集器，当发现堆中的活动数据超过了 50% 或者停顿时间过长（大于 500 ms）时效果较好





#### Region 分区

注意：Region 的角色在回收之后可以变更

一个 Region 只可能属于下面四个角色之一：

1. Eden
2. Survivor
3. Old / Tenured
4. Humongous：主要用于存放大对象（对象大小大于 1.5 个 Region）

设置 Humongous 的原因：短期存在的大对象如果直接分配到老年代会对垃圾收集带来负面影响，此时划分一个 H 区有利于削弱影响。注意，如果一个 H 区装不下一个大对象，那么会寻找更大的连续的 H 区进行存储，实在找不到只能进行 Full GC。G1 大多数行为都把 H 区当作是老年代的一部分来看待





#### G1 回收过程

一般有以下三个步骤：

1. Young GC：当 Eden 区空间耗尽时，会进行 Young GC，此时只会回收 Eden 和 Survivor 区，注意 Survivor 区满时不会触发 Young GC
2. Young GC + 老年代并发标记：默认内存使用 45% 时触发
3. Mixed GC

如果需要也会进行 Full GC，这是针对 GC 评估失败提供的一种失败保护机制，即强力回收

<br/>

**补充知识 —— 记忆集：**

1. 由于一个对象可以被多个不同区域引用，如果没有任何措施，则 GC 时需要遍历全部区域，这样会降低回收效率
2. 无论是 G1 还是其他分代收集器， JVM 都是使用「记忆集」来避免对堆的遍历
3. 每个 Region 都对应一个记忆集，每次引用类型写数据时都会产生「写屏障」中断操作，然后检查要写入的引用指向的对象是否和该引用对象在不同的 Region 区域，如果不同就会通过 CardTable 把相关引用信息记录到引用指向的对象的 Region 的记忆集中
4. 在 GC 根结点的时加入记忆集就可以保证不进行全局扫描，同时也能做到不遗漏

<br/>

**G1 回收过程：**

1. 扫描 -> 更新记忆集 -> 处理记忆集 -> 复制对象 -> 处理（强软弱虚）引用
2. STW 初始标记可达对象 -> 根区域扫描 -> 并发标记 -> SATB 算法再次标记 -> 独占清理 -> 并发清理
3. 混合回收：随着老年代对象增多，为了避免堆内存耗尽，在处理回收年轻代还会回收一部分老年代，默认会分 8 次回收老年代
4. Full GC：当并发处理过程完成之前空间就耗尽了，或者没有足够的空间存放晋升对象时会触发 Full GC
