---
title: "JVM 垃圾回收器"
shortTitle: "G-JVM 垃圾回收器"
description: "JVM 垃圾回收器"
icon: ""
author: 
  name: gzw
  url: 
  email: 1627121193@qq.com
isOriginal: false
date: 2022-06-11
category: 
- "java"
- "JVM"
- "虚拟机"
tag:
- "java"
- "JVM"
- "虚拟机"
sticky: 1
star: false
article: true
timeline: true,
dir:
  text: "JVM 垃圾回收器"
  icon: ""
  collapsible: true
  index: true
  comment: true
headerDepth: 3
index: true
order: 2
copy:
  triggerWords: 100
  disableCopy: false
  disableSelection: false
feed:
  title: "JVM 垃圾回收器"
  description: "JVM 垃圾回收器"
  author:
    name: gzw
    email: 1627121193@qq.com
---





# JVM 垃圾收集器

> 什么是垃圾：运行程序中没有任何「指针」指向的对象
>
> 为什么进行垃圾回收：不进行内存管理会造成内存泄露、内存溢出

经典三问：

1. 那些内存需要回收？
2. 什么时候回收？
3. 如何回收？

常见的两种标记算法：

1. 引用计数算法
2. 可达性分析算法

常见的三种回收算法：

1. 标记-清除算法
2. 标记-压缩算法
3. 赋值算法

垃圾回收步骤：

1. 确定内存中存活和死亡的对象
2. 执行垃圾回收，释放占用的内存空间





## 垃圾回收算法

标记阶段：

1. 引用计数算法
2. 可达性分析算法

清除阶段：

1. 标记-清除算法
2. 标记-压缩算法
3. 复制算法





### 引用计数

判断对象存活：一般有引用计数和可达性分析算法。当一个对象没有被任何对象引用时就不是存活的

引用计数就是对每个对象保存一个整型的引用计数器属性，用于记录对象被引用的次数

当对象 A 的引用计数器的值为 0 时表示该对象不可能再被使用，可以进行垃圾回收

优点：

1. 实现简单
2. 垃圾对象便于识别
3. 判定效率高，回收没有延迟性

缺点：

1. 需要单独的字段存储计数器，增加了存储空间的开销
2. 每次赋值都需要更新计数器，伴随加减操作，增加了时间开销
3. 无法处理「循环引用」的问题，这点非常严重，导致了 Java 的垃圾回收器中没有使用这类算法





### 可达性分析算法

> 也称为：跟搜索算法、追踪性垃圾收集

可以有效地解决引用计算算法中的循环引用问题，是较为常用的算法

**基本步骤：**

1. 以「根对象（GC Roots）」为起始点，按照从上到下的方式搜索被根对象集合连接的目标对象是否可达
2. 内存中的「存活对象」都会被根对象集合直接或者间接连接着，搜索时走过的路径称为「引用链」
3. 如果目标对象没有任何引用链相连就是不可达的，可以标记为垃圾对象

**根对象包括（非堆区的对象：栈、方法区、虚拟机、锁住的对象）：**

1. 虚拟机栈中引用的对象：比如各个线程调用的方法中使用到的参数、局部变量等
2. 本地方法栈内 JNI 引用的对象
3. 方法区中类静态属性引用的对象
4. 方法区中常量引用的对象：比如字符串常量池中引用的对象
5. 所有被同步锁 synchronizeed 持有的对象
6. 虚拟机内部的应用：比如基本数据类型对应的 Class 对象，一些常驻的异常对象，系统类加载器
7. 反应虚拟机内部情况的 JMXBean、JVMTI 中注册的回调、本地代码缓存等

**判断根对象的小技巧：保存了堆内存中的对象，但是自身又不再堆内存里面，那么大概率是一个根对象**

**注意点：**

1. 如果需要使用可达性分析算法，那么分析工作必须在一个能够保障「一致性」的快照进行，如果不能满足这一点，那么分析结果的准确性就无法保证
2. 这一点也导致了 GC 时必须「Stop The World」，即使是在号称（几乎）不会发生停顿的 CMS 收集器中，枚举根节点时也是必须要停顿的





### Finalization 机制

1. Java 提供了对象终止机制来允许开发人员提供对象被销毁之前的「自定义销毁逻辑」
2. 垃圾回收前，总会先调用这个对象的 `finalize()` 方法
3. `finalize()` 方法允许被子类重写，用于在对象被回收时进行资源释放。通常用于关闭文件、套接字、数据库连接等

注意点：不用调用某个对象的 `finalize()` 方法，应该交给垃圾回收机制调用，因为：

1. 在 `finalize()` 时可能导致对象复活
2. `finalize()`  方法的执行时间没有保障，完全由 GC 线程决定，极端情况下，如果不发生 GC，则 `finalize()` 方法将没有执行机会
3. 一个糟糕的 `finalize()` 重写会严重影响 GC 的性能

由于 `finalize()` 方法的存在，虚拟机中的对象一般处于三种可能的状态：

1. 可触及的：从跟节点出发，可以到达这个对象
2. 可复活的：对象的所有引用都被释放，但是对象有可能在 `finalize()` 方法中复活
3. 不可触及的：对象的 `finalize()` 方法被调用，并且没有复活，那么就会进入不可触及状态，该状态下对象不可能被复活，因为 `finalize()` 方法只会被调用一次。只有在对象不可触及时才可以被回收

判定一个对象是否可以回收，至少要经历两次标记：

1. 如果该对象没有引用链，进行第一次标记
2. 进行筛选：判断此对象是否有必要执行 `finalize()` 方法：
   1. 如果该对象没有重写 `finalize()` 方法，或者 `finalize()` 已经被虚拟机调用过，那么就视为没有必要执行，被判定为不可触及的
   2. 如果对象重写了 `finalize()` ，并且还没有执行，那么该对象会被插入到 F-Queue 队列中，由一个虚拟机自动创建的、低优先级的 Finalizer 线程触发其 `finalize()` 方法
   3. `finalize()`  方法时对象复活的最后机会，稍后 GC 会对 F-Queue 队列中的对象进行「二次标记」。如果该对象在 `finalize()` 中与引用链上的任意对象连接，那么在第二次标记时该对象就会被移出即将回收的集合中。之后对象会再次出现没有引用存在的情况，这个情况下，`finalize()` 方法不会被再次执行，对象会直接变成不可触及状态，也就是说，一个对象的 `finalize()` 方法只会被调用一次 





### 标记-清除算法

执行过程：

1. 当堆中的有效内存被耗尽时，会停止整个程序（STW），然后进行标记和清除工作
2. 标记就是收集器从引用根节点触发，标记所有被引用过的对象，一般是在对象的 Header 对象头中记录为可达对象
3. 清除就是收集器对堆内存从头到尾进行线性的遍历，如果发现否个对象没有标记为可达对象，就将其进行回收

缺点：

1. 效率不高
2. GC 时需要 STW
3. 清理出来的空闲内存不是连续的，还需要维护一个空闲列表

注意：这里的清除不是真的置空，而是把需要清除的对象地址保存在空闲地址列表里，新对象需要加载时就判断空间是否足够





### 复制算法

为了解决标记-清除算法效率低的问题，出现了复制算法

复制算法的核心思想：

1. 内存空间分为两块，每次只是用其中的一块
2. 在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象
3. 交换两个内存块的角色，最后完成垃圾回收

优点：

1. 没有标记和清除过程，实现简单，运行高效
2. 复制后能够保证空间连续，不会出现碎片

缺点：

1. 需要两倍的内存空间
2. 对于 G1 这种芬超成为大量 region 的 GC，复制而不是移动也就意味着 GC 时需要为胡 region 之间对象的引用关系，内存占用和时间开销都不小

注意：存活对象非常多时复制算法效率也比较低





### 标记-压缩算法

老年代中的对象一般都是存活的，使用复制算法不理想，出现了标记-压缩算法

标记压缩算法执行过程：

1. 第一阶段和标记-清除算法一样，即标记所有被引用的对象
2. 第二阶段将所有存活对象压缩到内存的一端，并按顺序排放
3. 清理边界外的所有空间

当需要给新对象分配内存时，JVM 只需要持有一个内存的起始地址即可，这样比维护一个空闲列表减小了许多开销（相比于标记-清除算法）

优点：

1. 消除了标记-清除算法内存区域分散的缺点
2. 消除了复制算法内存减半的代价

缺点：

1. 效率低于复制算法
2. 移动对象时，如果对象被其他对象引用，还需要调整引用的地址（Java 中不是用句柄池，而是直接引用）
3. 移动过程中，需要 STW

