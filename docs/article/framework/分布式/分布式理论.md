---
title: "分布式理论"
shortTitle: "分布式理论"
description: "分布式理论"
icon: ""
author: 
  name: gzw
  url: 
  email: 1627121193@qq.com
isOriginal: false
date: 2022-09-01
category: 
- "分布式"
- "小知识点"
tag:
- "分布式"
- "小知识点"
sticky: 1
star: false
article: true
timeline: true,
dir:
  text: "分布式理论"
  icon: ""
  collapsible: true
  index: true
  comment: true
headerDepth: 3
index: true
order: 2
copy:
  triggerWords: 100
  disableCopy: false
  disableSelection: false
feed:
  title: "分布式理论"
  description: "分布式理论"
  author:
    name: gzw
    email: 1627121193@qq.com
---





# 分布式理论



## CAP 理论

1. Consistency（一致性）：分布式系统的所有节点都能够访问同样的数据副本，并且在数据更新后所有节点都能够读取到最新的数据副本。也就是说，分布式系统中的所有节点看到的数据是相同的。
2. Availability（可用性）：分布式系统的每个请求都能够得到响应，不管是成功或失败，都能够得到一个明确的响应。即使出现了节点故障或者网络分区，系统仍然能够保证对请求的响应。
3. Partition Tolerance（分区容错性）：分布式系统在遇到节点故障或者网络分区的情况下，仍然能够正常工作。

:::warning 注意

CAP 三者不可兼得，而且一般都是必须保证分区容错性的，所以就有：

CP：保证数据一致性，牺牲一点可用性

AP：保证可用性，牺牲一点数据一致性

:::



## Base 理论

:::info 说明

Base理论主要针对分布式系统的高可用性和数据一致性问题，强调了在分布式系统中应该以可用性和分区容错性为首要目标，而不是一致性。因为在分布式系统中，实现一致性需要付出巨大的代价，而对于许多应用场景来说，一定程度的数据不一致是可以接受的。因此，Base理论提出了通过容错性和异步处理来达到最终一致性的策略。

:::

- 基本可用性（Basically Available）：系统在出现故障时，仍然可以保证一定的可用性，即系统可以继续提供部分服务。
- 软状态（Soft State）：系统中的状态可以不是实时一致的，即在某个时刻不同的节点可能会有不同的数据状态。但这种不一致是临时的，最终会达成一致。
- 最终一致性（Eventual Consistency）：系统中的数据最终会达到一致状态，但这种一致性是异步的，在一段时间内可能会存在数据不一致的情况。

需要注意的是，Base理论并不是一个完整的理论，而是一系列策略的组合。实际上，在分布式系统中要根据具体情况来选择合适的策略。例如，有些应用需要更高的一致性，就需要采用更加复杂的分布式算法来实现一致性。而有些应用则更加关注可用性和性能，因此可以采用Base理论中的策略来优化分布式系统。



## RPC

RPC（Remote Procedure Call，远程过程调用）是一种计算机通信协议，它允许一个计算机程序通过网络访问另一个计算机程序的服务，就像调用本地服务一样，让远程服务就像本地服务一样方便地调用。

在 RPC 中，客户端调用远程服务时，就像调用本地服务一样，RPC 框架会自动帮助客户端把请求参数序列化，通过网络发送到远程服务，远程服务收到请求后反序列化请求参数，执行相应的业务逻辑，将结果序列化后返回给客户端，客户端再反序列化结果，得到最终结果。

RPC 框架通常包含以下组件：

- 序列化和反序列化组件：负责将数据结构序列化成二进制格式并反序列化成数据结构。
- 传输协议组件：负责将数据结构打包和解包，通过网络传输。
- 通信协议组件：负责定义客户端和服务端之间的通信协议，如HTTP、TCP、UDP等。
- 客户端存根组件：负责将远程过程调用转换为本地函数调用，并向服务器发送请求。
- 服务端存根组件：负责接收客户端请求，解析请求参数并调用实际的业务逻辑。

RPC 的使用场景包括分布式系统、微服务架构、SOA（面向服务的架构）等。通过使用 RPC，可以将分布式系统中的服务进行解耦，让服务之间能够方便地通信和调用，提高系统的可扩展性和可维护性。常见的 RPC 框架有 gRPC、Dubbo、Thrift 等。





## 数据一致性模型

数据一致性模型是指在分布式系统中，多个节点在进行数据读写操作时，如何保证数据的一致性。下面介绍一些常见的数据一致性模型：

1. 强一致性（Strong Consistency）：强一致性要求系统中的每个节点在进行数据读写时，都能够读写到最新的数据。强一致性模型适用于对数据一致性要求非常高的场景，如银行系统等。强一致性可以通过Paxos、Raft等算法实现。
2. 弱一致性（Weak Consistency）：弱一致性是指系统中的节点在进行数据读写时，可能会读到旧数据，但是最终数据会达到一致性。弱一致性适用于数据一致性要求不是非常高的场景，如社交网络等。弱一致性可以通过Gossip、CRDT等算法实现。
3. 最终一致性（Eventual Consistency）：最终一致性是指系统中的节点在进行数据读写时，可能会读到旧数据，但是最终数据会达到一致性。最终一致性适用于数据一致性要求不是非常高的场景，如云存储等。最终一致性可以通过基于版本号或时间戳的算法实现。
4. 会话一致性（Session Consistency）：会话一致性是指在同一会话中，每个节点在进行数据读写时，都能够读写到最新的数据。会话一致性适用于对数据一致性要求较高的场景，如电商系统等。会话一致性可以通过基于时间戳或基于版本号的算法实现。

不同的数据一致性模型具有不同的优缺点，开发人员需要根据具体业务场景选择合适的数据一致性模型。







## 分布式锁

分布式锁的应用场景：

1. 分布式系统中多个实例对共享资源的互斥访问，如秒杀系统中对某个商品库存的互斥访问。
2. 防止重复操作，如定时任务中同一时刻只能有一个实例执行任务。
3. 限流控制，如对API接口的访问次数限制。
4. 分布式事务中，用于保证数据的一致性。

现在常用的分布式锁方案有：

1. Redis分布式锁（保证 AP）：利用Redis的原子操作实现分布式锁，通过SETNX和EXPIRE命令来实现锁的获取和释放，支持阻塞和非阻塞模式。
2. ZooKeeper分布式锁（保证 CP）：利用ZooKeeper的特性来实现分布式锁，ZooKeeper提供了临时节点和Watch机制，可以实现分布式锁的获取和释放，需要客户端保持长连接，因此不适合高并发场景。
3. 基于数据库的分布式锁：利用数据库的事务和行级锁来实现分布式锁，通过在数据库中创建唯一约束或行锁来实现互斥访问，支持各种数据库，但性能较低，不适合高并发场景。
4. 基于Redis和Lua脚本的分布式锁：将获取锁和释放锁的操作封装在Lua脚本中，可以减少网络延迟和减少代码复杂度，性能较高，但需要客户端支持Lua脚本执行。

在实际场景中，需要根据具体的业务需求和系统特点选择适合的分布式锁方案。

