---
title: "分布式事务"
shortTitle: "分布式事务"
description: "分布式事务"
icon: ""
author: 
  name: gzw
  url: 
  email: 1627121193@qq.com
isOriginal: false
date: 2022-09-05
category: 
- "分布式"
- "小知识点"
tag:
- "分布式"
- "小知识点"
sticky: 1
star: false
article: true
timeline: true
dir:
  text: "分布式事务"
  icon: ""
  collapsible: true
  index: true
  comment: true
headerDepth: 3
index: true
order: 2
copy:
  triggerWords: 100
  disableCopy: false
  disableSelection: false
feed:
  title: "分布式事务"
  description: "分布式事务"
  author:
    name: gzw
    email: 1627121193@qq.com
---





# 分布式事务

分布式事务解决方案主要包括以下几种：

1. 两阶段提交（Two-Phase Commit，2PC）：在分布式系统中，所有的事务参与者都通过协调者来协同完成事务的提交，2PC 是一种最基本的分布式事务解决方案，它可以保证所有参与者要么全部提交成功，要么全部回滚，但是它存在效率低、单点故障等缺点。
2. 三阶段提交（Three-Phase Commit，3PC）：3PC 在 2PC 基础上增加了超时机制，可以避免某个参与者出现网络异常、挂掉等问题导致的长时间阻塞，从而提高了系统的可用性，但是仍然存在单点故障问题。
3. 补偿事务（Compensating Transaction）：在分布式系统中，当事务发生错误或部分失败时，通过执行补偿事务将数据恢复到原始状态，补偿事务是一种常见的分布式事务解决方案，但是它需要额外的开发工作，并且对于某些场景，无法进行补偿操作。
4. TCC（Try-Confirm-Cancel）：TCC 是一种面向业务逻辑的分布式事务解决方案，它通过预留资源、确认资源和释放资源三个阶段来实现事务的一致性，相对于 2PC、3PC 等解决方案，TCC 的性能更高，但是需要应用程序开发者在业务逻辑中实现 TCC 接口。
5. Saga：Saga 是一种基于补偿事务的分布式事务解决方案，将整个事务拆分为多个子事务，并针对每个子事务编写补偿事务逻辑，从而实现整个事务的一致性，Saga 相对于 2PC、3PC 等解决方案，具有更好的可扩展性和可维护性。
6. 本地消息表（Local Message Table）：将分布式事务的提交和回滚操作转换为对本地消息表的操作，本地消息表是一种在单机环境下的本地事务，可以保证数据的一致性，通过消息队列将本地消息表的操作同步到远程节点上，从而实现分布式事务的一致性。
7. 使用消息队列实现事务





## JTA 

JTA（Java Transaction API）是 Java EE 平台上的一个规范，它定义了一种标准的方式，用于在分布式环境中管理事务的协议和 API。JTA API 定义了一组接口，使得应用程序能够与事务管理器进行交互，从而实现跨多个资源管理器（如数据库、JMS 队列等）的事务管理。

JTA 使用了两个协议：XA 和 JTS。其中，XA 协议定义了一个事务管理器和多个资源管理器之间的通信协议。JTS 协议在 XA 协议的基础上，定义了事务管理器和应用服务器之间的通信协议。

JTA 通过以下步骤来管理分布式事务：

1. 获取一个全局事务对象，它包含多个资源管理器。
2. 对于每个参与者（即资源管理器），创建一个本地事务对象。
3. 启动全局事务，也就是启动每个本地事务。
4. 执行事务过程中的各种操作。
5. 在所有操作完成后，提交全局事务，也就是提交所有本地事务。
6. 如果有任何一个本地事务提交失败，则回滚所有本地事务，撤销之前的操作。

JTA 的优点在于它提供了一个标准化的方式来管理分布式事务，使得开发者可以更加方便地进行事务管理，同时保证了事务的一致性和可靠性。但是，JTA 也存在一些缺点，比如性能较低，需要使用额外的资源管理器等。因此，在实际应用中，开发者需要根据实际情况选择合适的分布式事务解决方案。





## 2PC

![image-20230313215732684](https://my-photos-1.oss-cn-hangzhou.aliyuncs.com/markdown//%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/20230313/%E4%B8%A4%E9%98%B6%E6%AE%B5%E5%8D%8F%E8%AE%AE.png)

分为「准备阶段」和「提交阶段」：

1. 准备阶段：「事务管理器」给每个参与者发送 Prepare 消息，每个数据库参与者在本地执行事务，并写本地的 Undo/Redo 日志，此时事务未提交
2. 提交阶段：
   1. 如果「事务管理器」收到了参与者「执行失败」或者「超时消息」时，直接给每个参与者发送「回滚消息」，否则发送「提交消息」
   2. 参与者根据事务管理器的指令执行提交或者回滚操作，并释放事务处理过程中使用的「锁资源」（必须在最后阶段释放）



### XA 的 2PC 解决方案

2PC 的传统方案是在数据库层面实现的，如 Oracle、MySQL 都支持 2PC 协议，为了统一标准减少行业内不必要的对接成本，需要制定标准化的处理模型及接口标准，国际开放标准组织 Open Group 定义了分布式事务处理模型 DTP（Distributed Transaction Processing Reference Model）

DTP 模型定义如下角色：

1. AP（Application Program）：即应用程序，可以理解为使用DTP分布式事务的程序
2. RM（Resource Manager）：即资源管理器，可以理解为事务的参与者，一般情况下是指一个数据库实例，通过资源管理器对该数据库进行控制，资源管器控制着分支事务
3. TM（Transaction Manager）：事务管理器，负责协调和管理事务，事务管理器控制着全局事务，管理事务生命周期，并协调各个M。全局事务是指分布式事务处理环境中，需要操作多个数据库共同完成一个工作，这个工作即是一个全局事务

DTP 模型定义 TM 和 RM 之间通讯的接口规范叫 XA，简单理解为数据库提供的 2PC 接口协议，基于数据库的 XA 协议来实现的 2PC 又称为 XA 方案

TM 向 AP 提供应用程序编程接口，AP 通过 TM 提交以及回滚事务

TM 交易中间件通过 XA 接口来通知 RM 数据库事务的开始、结束、提交、回滚

:::info 补充

1. XA 规范是为了解决分布式事务问题而产生的一种标准规范，它定义了在分布式事务环境下，各参与方如何协调完成事务的提交或回滚，从而保证分布式事务的一致性
2. XA 规范的实现方式通常采用两阶段提交（Two-Phase Commit，简称2PC）协议。2PC协议由协调器（Coordinator）、参与者（Participant）两个角色组成，分为投票阶段（Voting Phase）和提交阶段（Commit Phase）
3. 在投票阶段，协调器将事务的提交请求发送给所有参与者，并询问参与者是否可以提交事务。如果所有参与者都回复「可以提交」，则进入提交阶段；否则，进入回滚阶段
4. 在提交阶段，协调器通知所有参与者提交事务，并等待所有参与者提交成功的响应。如果有任何一个参与者提交失败，则协调器通知所有参与者回滚事务。
5. XA 规范的优点是可以保证数据的强一致性，但同时也存在着性能和可靠性上的问题。在实际应用中，通常使用更轻量级的方案，如 TCC、消息队列等来实现分布式事务

:::

:::warning 缺点

1. 需要本地数据库支持 XA 协议
2. 资源锁需要等到两个阶段结束后才能释放，性能较差
3. 单点故障：一旦事务管理器出现故障，整个系统不可用（参与者都会阻塞住）
4. 数据不一致：在阶段二，如果事务管理器只发送了部分 commit 消息，此时网络发生异常，那么只有部分参与者接收到 commit 消息，也就是说只有部分参与者提交了事务，使得系统数据不一致。
5. 响应时间较长：参与者和协调者资源都被锁住，提交或者回滚之后才能释放
6. 不确定性：当协事务管理器发送 commit 之后，并且此时只有一个参与者收到了 commit，那么当该参与者与事务管理器同时宕机之后，重新选举的事务管理器无法确定该条消息是否提交成功。

:::





### Seata 的 2PC 解决方案

Seata 是由阿里中间件团队发起的开源项目 Fescar，后更名为 Seata，它是一个是开源的分布式事务框架

传统 2PC 的问题在 Seata 中得到了解决，它通过对本地关系数据库的分支事务的协调来驱动完成全局事务，是工作在应用层的中间件

主要优点是性能较好，且不长时间占用连接资源，它以高效并且对业务0侵入的方式解决微服务场景下面临的分布式事务问题，它目前提供：AT 模式（即2PC）及 TCC 模式的分布式事务解决方案

<br/>

**Seata 的设计思想：**

1. Seata 的设计目标其一是对业务无侵入，因此从业务无侵入的 2PC 方案着手，在传统 2PC 的基础上演进，并解决 2PC 方案面临的问题
2. Seata 把一个分布式事务理解成一个包含了若干「分支事务」的「全局事务」。全局事务的职责是协调其下管辖的分支事务达成一致，要么一起成功提交，要么一起失败回滚
3. 此外，通常分支事务本身就是一个关系数据库的本地事务

<br/>

**Seata 的 2PC 方案：**

1. Seata 的 2PC 中还额外增加了 TC（事务协调器），它是独立的中间件，需要独立部署运行，负责维护「全局事务」的运行状态，接收 TM 指令发起全局事务的「提交」与「回滚」，负责与 RM 通信，协调各个「分支事务」的提交与回滚
2. Transaction Manager（TM）：事务管理器，TM 需要嵌入应用程序中工作，它负责开启一个全局事务，并最终向 TC 发起全局提交或全局回滚的指令
3. Resource Manager（RM）：控制分支事务，负责分支注册、状态汇报，并接收事务协调器 TC 的指令，驱动分支（本地）事务的提交和回滚

<br/>

**案例说明：**

![Seata2PC案例](https://my-photos-1.oss-cn-hangzhou.aliyuncs.com/markdown//seata/20230729/Seata2PC%E6%A1%88%E4%BE%8B.png)

具体的执行流程如下：

1. 用户服务的 TM 向 TC 申请开启一个全局事务，全局事务创建成功并生成一个全局唯一的 XD
2. 用户服务的 RM 向 TC 注册分支事务，该分支事务在用户服务执行新增用户逻辑，并将其纳入 ⅪD 对应全局事务的管辖
3. 用户服务执行分支事务，向用户表插入一条记录
4. 逻辑执行到远程调用积分服务时（XID 在微服务调用链路的上下文中传播）。积分服务的 RM 向 TC 注册分支事务，该分支事务执行增加积分的逻辑，并将其纳入 ⅪD 对应全局事务的管辖
5. 积分服务执行分支事务，向积分记录表插入一条记录，执行完毕后，返回用户服务
6. 用户服务分支事务执行完毕
7. TM 向 TC 发起针对 ID 的「全局提交」或「回滚决议」
8. TC 调度 XID 下管辖的全部分支事务完成提交或回滚请求

 <br/>

**Seata 2PC 与传统 2PC 的差别：**

1. 架构层次方面，传统 2PC 方案的 RM 实际上是在数据库层，RM 本质上就是数据库自身，通过 XA 协议实现，而 Seata 的 RM 是以 jar 包的形式作为中间件层部署在应用程序这一侧的
2. 两阶段提交方面，传统 2PC 无论第二阶段的决议是提交还是回滚，事务性资源的锁都要保持到完成才释放。而 Seata 的做法是在阶段一就将本地事务提交，这样就可以省去阶段二持锁的时间，整体提高效率





## 3PC

![image-20230313215654348](https://my-photos-1.oss-cn-hangzhou.aliyuncs.com/markdown//%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/20230313/%E4%B8%89%E9%98%B6%E6%AE%B5%E5%8D%8F%E8%AE%AE.png)

> 三阶段协议：主要是针对两阶段的优化，解决了2PC单点故障的问题，但是性能问题和不一致问题仍然没有根本解决

引入了超时机制解决参与者阻塞的问题，超时后本地提交，2pc只有协调者有超时机制。

1. 第一阶段：CanCommit阶段，协调者询问事务参与者，是否有能力完成此次事务。如果都返回yes，则进入第二阶段有一个返回no或等待响应超时，则中断事务，并向所有参与者发送abort请求
2. 第二阶段：PreCommit阶段，此时协调者会向所有的参与者发送PreCommit请求，参与者收到后开始执行事务操作。参与者执行完事务操作后（此时属于未提交事务的状态），就会向协调者反馈“Ack”表示我已经准备好提交了，并等待协调者的下一步指令。
3. 第三阶段：DoCommit阶段， 在阶段二中如果所有的参与者节点都返回了Ack，那么协调者就会从
4. “预提交状态”转变为“提交状态”。然后向所有的参与者节点发送"doCommit"请求，参与者节点在收到提交请求后就会各自执行事务提交操作，并向协调者节点反馈“Ack”消息，协调者收到所有参与者的Ack消息后完成事务。 相反，如果有一个参与者节点未完成PreCommit的反馈或者反馈超时，那么协调者都会向所有的参与者节点发送abort请求，从而中断事务。





## TCC

> TCC（补偿事务）：Try、Confirm、Cancel，针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作

:::info 说明

Try 操作做业务检查及资源预留，Confirm 做业务确认操作，Cancel 实现一个与 Try 相反的操作既回滚操作

TM 首先发起所有的分支事务的 try 操作，任何一个分支事务的 try 操作执行失败，TM 将会发起所有分支事务的 cancel 操作，若 try 操作全部成功，TM 将会发起所有分支事务的 confirm 操作，其中 confirm/cancel 操作若执行失败，TM 会进行重试

TCC 模型对业务的「侵入性较强」，改造的难度较大，每个操作都需要有 try 、 confirm 、 cancel 三个接口实现。而且 confirm 和 cancel 接口还必须实现幂等性

:::

**TCC 分为三个阶段：**

1. try 阶段是做业务检查（一致性）及资源预留（隔离），此阶段仅是一个初步操作，它和后续的 confirm 一起才能真正构成一个完整的业务逻辑
2. confirm 阶段是做确认提交，try 阶段所有分支事务执行成功后开始执行 confirm。通常情况下，采用 TCC 则认为 confirm 阶段是不会出错的。即：只要 try 成功，confirm 一定成功。若 confirm阶段真的出错了，需引入重试机制或人工处理
3. cancel 阶段是在业务执行错误需要回滚的状态下执行分支事务的业务取消，预留资源释放。通常情况下，采用 TCC 则认为 cancel 阶段也是一定成功的。若 cancel 阶段真的出错了，需引入重试机制或人工处理

<br/>

TM 事务管理器可以实现为独立的服务，也可以让全局事务发起方充当 TM 的角色，TM 独立出来是为了成为公用组件，是为了考虑系统结构和软件复用

TM 在发起全局事务时生成全局事务记录，全局事务 XID 贯穿整个分布式事务调用链条，用来记录事务上下文，追踪和记录状态，由于 confirm 和 cancel 失败需进行重试，因此需要实现为幂等，幂等性是指同一个操作无论请求多少次，其结果都相同

<br/>

**TCC 需要注意三种异常处理：**

1. 空回滚：没有 try 就直接执行了 cancel，通常是网络异常或者服务宕机造成的，如果识别不出会造成空回滚
2. 幂等：为了保证提交可能会不断重试，如果没有做好幂等则会导致数据不一致
3. 悬挂：cancel 比 try 先执行，通常是由于 RPC 调用网络拥堵，超时后先执行了 cancel 随后请求到达再执行 try，此时对应的资源只能由分布式事务使用，这样该资源就不能被处理，即业务资源预留后无法继续处理称之为悬挂。解决方法是二阶段如果已经执行那么一阶段 try 就不能执行

**常用的 TCC 框架：**

1. tcc-transaction
2. Hmily
3. ByteTCC
4. EasyTransaction

:::note 优劣势

如果拿 TCC 事务的处理流程与 2PC 两阶段提交做比较，2PC 通常都是在跨库的 DB 层面，而 TCC 则在应用层面的处理，需要通过业务逻辑来实现。这种分布式事务的实现方式的优势在于，可以让应用自己定义数据操作的粒度，使得降低锁冲突、提高吞吐量成为可能

而不足之处则在于对应用的侵入性非常强，业务逻辑的每个分支都需要实现 try、confirm、cancel 三个操作。此外，其实现难度也比较大，需要按照网络状态、系统故障等不同的失败原因实现不同的回滚策略

:::



## 可靠消息最终一致性

:::info 说明

可靠消息最终一致性就是保证消息从生产方经过消息中间件传递到消费方后，消息一定能够被消费，主要涉及两个问题：

1. 本地事务与消息发送的原子性问题
2. 事务参与方接收消息的可靠性

可靠消息最终一致性事务适合执行周期长且实时性要求不高的场景。引入消息机制后，同步的事务操作变为基于消息执行的异步操作，避免了分布式事务中的同步阻塞操作的影响，并实现了两个服务的解耦

:::

实现方案：

1. 本地消息表方案
2. 消息队列事务消息





### 消息队列事务

消息队列的事务消息：

1. 发送prepare消息到消息中间件

2. 发送成功后，执行本地事务

3. 如果事务执行成功，则commit，消息中间件将消息下发至消费端（commit前，消息不会被消费）
4. 如果事务执行失败，则回滚，消息中间件将这条prepare消息删除
5. 消费端接收到消息进行消费，如果消费失败，则不断重试





## 最大努力通知

发起通知方通过一定的机制，尽最大努力将业务处理结果通知接收方

需要考虑：

1. 消息重复通知机制
2. 消息校对机制

可靠消息一致性关注交易过程的事务一致性，以异步的方式完成交易   

最大努力通知关注的是交易后的通知事务，即将交易结果可靠地通知出去，但是无法保证消息从发出到接收的一致性，只提供消息接收的可靠机制。当消息无法被接收方接收时，需要由接收方主动查询消息（业务处理结果）