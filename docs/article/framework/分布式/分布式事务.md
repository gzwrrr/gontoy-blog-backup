---
title: "分布式事务"
shortTitle: "分布式事务"
description: "分布式事务"
icon: ""
author: 
  name: gzw
  url: 
  email: 1627121193@qq.com
isOriginal: false
date: 2022-09-05
category: 
- "分布式"
- "小知识点"
tag:
- "分布式"
- "小知识点"
sticky: 1
star: false
article: true
timeline: true,
dir:
  text: "分布式事务"
  icon: ""
  collapsible: true
  index: true
  comment: true
headerDepth: 3
index: true
order: 2
copy:
  triggerWords: 100
  disableCopy: false
  disableSelection: false
feed:
  title: "分布式事务"
  description: "分布式事务"
  author:
    name: gzw
    email: 1627121193@qq.com
---





# 分布式事务

分布式事务解决方案主要包括以下几种：

1. 两阶段提交（Two-Phase Commit，2PC）：在分布式系统中，所有的事务参与者都通过协调者来协同完成事务的提交，2PC 是一种最基本的分布式事务解决方案，它可以保证所有参与者要么全部提交成功，要么全部回滚，但是它存在效率低、单点故障等缺点。
2. 三阶段提交（Three-Phase Commit，3PC）：3PC 在 2PC 基础上增加了超时机制，可以避免某个参与者出现网络异常、挂掉等问题导致的长时间阻塞，从而提高了系统的可用性，但是仍然存在单点故障问题。
3. 补偿事务（Compensating Transaction）：在分布式系统中，当事务发生错误或部分失败时，通过执行补偿事务将数据恢复到原始状态，补偿事务是一种常见的分布式事务解决方案，但是它需要额外的开发工作，并且对于某些场景，无法进行补偿操作。
4. TCC（Try-Confirm-Cancel）：TCC 是一种面向业务逻辑的分布式事务解决方案，它通过预留资源、确认资源和释放资源三个阶段来实现事务的一致性，相对于 2PC、3PC 等解决方案，TCC 的性能更高，但是需要应用程序开发者在业务逻辑中实现 TCC 接口。
5. Saga：Saga 是一种基于补偿事务的分布式事务解决方案，将整个事务拆分为多个子事务，并针对每个子事务编写补偿事务逻辑，从而实现整个事务的一致性，Saga 相对于 2PC、3PC 等解决方案，具有更好的可扩展性和可维护性。
6. 本地消息表（Local Message Table）：将分布式事务的提交和回滚操作转换为对本地消息表的操作，本地消息表是一种在单机环境下的本地事务，可以保证数据的一致性，通过消息队列将本地消息表的操作同步到远程节点上，从而实现分布式事务的一致性。
7. 使用消息队列实现事务





### XA 规范

XA规范是为了解决分布式事务问题而产生的一种标准规范，它定义了在分布式事务环境下，各参与方如何协调完成事务的提交或回滚，从而保证分布式事务的一致性。

XA规范的实现方式通常采用两阶段提交（Two-Phase Commit，简称2PC）协议。2PC协议由协调器（Coordinator）、参与者（Participant）两个角色组成，分为投票阶段（Voting Phase）和提交阶段（Commit Phase）。

在投票阶段，协调器将事务的提交请求发送给所有参与者，并询问参与者是否可以提交事务。如果所有参与者都回复“可以提交”，则进入提交阶段；否则，进入回滚阶段。

在提交阶段，协调器通知所有参与者提交事务，并等待所有参与者提交成功的响应。如果有任何一个参与者提交失败，则协调器通知所有参与者回滚事务。

XA规范的优点是可以保证数据的强一致性，但同时也存在着性能和可靠性上的问题。在实际应用中，通常使用更轻量级的方案，如TCC、消息队列等来实现分布式事务。





### JTA

JTA（Java Transaction API）是 Java EE 平台上的一个规范，它定义了一种标准的方式，用于在分布式环境中管理事务的协议和 API。JTA API 定义了一组接口，使得应用程序能够与事务管理器进行交互，从而实现跨多个资源管理器（如数据库、JMS 队列等）的事务管理。

JTA 使用了两个协议：XA 和 JTS。其中，XA 协议定义了一个事务管理器和多个资源管理器之间的通信协议。JTS 协议在 XA 协议的基础上，定义了事务管理器和应用服务器之间的通信协议。

JTA 通过以下步骤来管理分布式事务：

1. 获取一个全局事务对象，它包含多个资源管理器。
2. 对于每个参与者（即资源管理器），创建一个本地事务对象。
3. 启动全局事务，也就是启动每个本地事务。
4. 执行事务过程中的各种操作。
5. 在所有操作完成后，提交全局事务，也就是提交所有本地事务。
6. 如果有任何一个本地事务提交失败，则回滚所有本地事务，撤销之前的操作。

JTA 的优点在于它提供了一个标准化的方式来管理分布式事务，使得开发者可以更加方便地进行事务管理，同时保证了事务的一致性和可靠性。但是，JTA 也存在一些缺点，比如性能较低，需要使用额外的资源管理器等。因此，在实际应用中，开发者需要根据实际情况选择合适的分布式事务解决方案。





### 两阶段协议

![image-20230313215732684](https://my-photos-1.oss-cn-hangzhou.aliyuncs.com/markdown//%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/20230313/%E4%B8%A4%E9%98%B6%E6%AE%B5%E5%8D%8F%E8%AE%AE.png)

1. 第一阶段（ prepare ） ：每个参与者执行本地事务但不提交，进入 ready 状态，并通知协调者已经准备就绪。
2. 第二阶段（ commit ） 当协调者确认每个参与者都 ready 后，通知参与者进行 commit 操作；如果有参与者 fail ，则发送 rollback 命令，各参与者做回滚。

**问题：**

1. 单点故障：一旦事务管理器出现故障，整个系统不可用（参与者都会阻塞住）

2. 数据不一致：在阶段二，如果事务管理器只发送了部分 commit 消息，此时网络发生异常，那么只有部分参与者接收到 commit 消息，也就是说只有部分参与者提交了事务，使得系统数据不一致。

3. 响应时间较长：参与者和协调者资源都被锁住，提交或者回滚之后才能释放
4. 不确定性：当协事务管理器发送 commit 之后，并且此时只有一个参与者收到了 commit，那么当该参与者与事务管理器同时宕机之后，重新选举的事务管理器无法确定该条消息是否提交成功。



### 三阶段协议

![image-20230313215654348](https://my-photos-1.oss-cn-hangzhou.aliyuncs.com/markdown//%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/20230313/%E4%B8%89%E9%98%B6%E6%AE%B5%E5%8D%8F%E8%AE%AE.png)

> 三阶段协议：主要是针对两阶段的优化，解决了2PC单点故障的问题，但是性能问题和不一致问题仍然没有根本解决

引入了超时机制解决参与者阻塞的问题，超时后本地提交，2pc只有协调者有超时机制。

1. 第一阶段：CanCommit阶段，协调者询问事务参与者，是否有能力完成此次事务。如果都返回yes，则进入第二阶段有一个返回no或等待响应超时，则中断事务，并向所有参与者发送abort请求
2. 第二阶段：PreCommit阶段，此时协调者会向所有的参与者发送PreCommit请求，参与者收到后开始执行事务操作。参与者执行完事务操作后（此时属于未提交事务的状态），就会向协调者反馈“Ack”表示我已经准备好提交了，并等待协调者的下一步指令。
3. 第三阶段：DoCommit阶段， 在阶段二中如果所有的参与者节点都返回了Ack，那么协调者就会从
4. “预提交状态”转变为“提交状态”。然后向所有的参与者节点发送"doCommit"请求，参与者节点在收到提交请求后就会各自执行事务提交操作，并向协调者节点反馈“Ack”消息，协调者收到所有参与者的Ack消息后完成事务。 相反，如果有一个参与者节点未完成PreCommit的反馈或者反馈超时，那么协调者都会向所有的参与者节点发送abort请求，从而中断事务。





### TCC

> TCC（补偿事务）：Try、Confirm、Cancel，针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作

Try操作做业务检查及资源预留，Confirm做业务确认操作，Cancel实现一个与Try相反的操作既回滚操作。TM首先发起所有的分支事务的try操作，任何一个分支事务的try操作执行失败，TM将会发起所有分支事务的Cancel操作，若try操作全部成功，TM将会发起所有分支事务的Confirm操作，其中Confirm/Cancel操作若执行失败，TM会进行重试。

TCC模型对业务的侵入性较强，改造的难度较大，每个操作都需要有 try 、 confirm 、 cancel 三个接口实现。而且 confirm 和 cancel 接口还必须实现幂等性。





### 消息队列事务

消息队列的事务消息：

1. 发送prepare消息到消息中间件

2. 发送成功后，执行本地事务

3. 如果事务执行成功，则commit，消息中间件将消息下发至消费端（commit前，消息不会被消费）
4. 如果事务执行失败，则回滚，消息中间件将这条prepare消息删除
5. 消费端接收到消息进行消费，如果消费失败，则不断重试