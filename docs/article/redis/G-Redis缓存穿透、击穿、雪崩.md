---
title: "Redis 缓存穿透、击穿、雪崩"
shortTitle: "G-Redis 缓存穿透、击穿、雪崩"
description: "Redis 缓存穿透、击穿、雪崩"
icon: ""
author: 
  name: gzw
  url: 
  email: 1627121193@qq.com
isOriginal: false
date: 2022-02-22
category: 
- "redis"
- "数据库"
- "缓存"
tag:
- "redis"
- "数据库"
- "缓存"
sticky: 1
star: false
article: true
timeline: true,
dir:
  text: "Redis 缓存穿透、击穿、雪崩"
  icon: ""
  collapsible: true
  index: true
  comment: true
headerDepth: 3
index: true
order: 2
copy:
  triggerWords: 100
  disableCopy: false
  disableSelection: false
feed:
  title: "Redis 缓存穿透、击穿、雪崩"
  description: "Redis 缓存穿透、击穿、雪崩"
  author:
    name: gzw
    email: 1627121193@qq.com
---



# Redis 缓存穿透、击穿、雪崩

## 1.缓存穿透

- 当用户查询数据时，要是 redis 中没有，即缓存没命中，就会到数据库中查询，要是在数据库中也没有，那么本次查询失败
- 当用户很多或者有人恶意执行上述查询失败的操作时，就会造成数据库压力很大，此时就相当于出现了缓存穿透
- 解决方案：
  - 接口层增加校验，如用户鉴权校验，id做基础校验，id<=0的直接拦截；
  - redis 存储空对象：当存储层没命中时，将返回的空对象也存入 redis 中，同时设置一个过期时间，之后再访问这个数据时就避免了直接访问数据库。但这种方法会浪费很多空间存储空值的键，并且即使设置了过期时间，缓存层和存储层还是会有一段时间窗口不一致，这对于需要保持一致性的业务会产生影响
  - 布隆过滤器：是一种数据结构，对所有可能查询的参数以 hash 形式存储，在控制层先进行校验，不符合则直接丢弃，避免了对底层存储系统的压力



## 2.缓存击穿

- 是指某个键在扛着高并发时可能会出现失效的情况
- 当这个键被击穿或缓存过期后会有大量请求打入数据库，并且还会写回缓存，这会导致数据库和服务器压力过大
- 解决方案：
  - 设置热点数据不过期
  - 加互斥锁：使用分布式锁保证对于每个 key 同时只有一个线程查询，其他线程在没有获得锁时只能等待，从而降低压力，但是这样会将压力转移到分布式锁上，所以分布式锁必须设计好
  - 接口限流与熔断，降级。重要的接口一定要做好限流策略，防止用户恶意刷接口，同时要降级准备，当接口中的某些 服务 不可用时候，进行熔断，失败快速返回机制。



## 3.缓存雪崩

- 是指在某个时间段缓存集中过期失效，或是 redis 服务不可用

- 解决方案：
  - 设置热点数据永远不过期
  - 增设多几个 redis，即将 redis 集群扩容，保证服务高可用（搭建异地多活），如果缓存数据库是分布式部署，将热点数据均匀分布在不同的缓存数据库中
  - 限流降级：在缓存失效后，通过加锁或队列来控制读数据库和写缓存得线程数量
  - 数据预热：就是在正式部署之前把可能查询的数据预先访问一遍，这样部分可能大量访问的数据就会先加载到缓存中。在即将发生高并发访问前手动触发加载缓存并设置不同的过期时间，让缓存失效的时间点不会集中在一起



## 4.缓存污染

- 缓存污染问题说的是缓存中一些只会被访问一次或者几次的的数据，被访问完后，再也不会被访问到，但这部分数据依然留存在缓存中，消耗缓存空间。
- 缓存污染会随着数据的持续增加而逐渐显露，随着服务的不断运行，缓存中会存在大量的永远不会再次被访问的数据。缓存空间是有限的，如果缓存空间满了，再往缓存里写数据时就会有额外开销，影响Redis性能。这部分额外开销主要是指写的时候判断淘汰策略，根据淘汰策略去选择要淘汰的数据，然后进行删除操作。
- 关键在于 **最大缓存设置多大** 以及选择怎么样的 **缓存淘汰策略**
  - 设置最大缓存可以通过：`CONFIG SET maxmemory xxgb` 来设置
  - 缓存淘汰策略有八种，分别是：
    - 不淘汰 ` noeviction` （默认策略） 
    - 对设置了时间的数据进行淘汰： `volatile-random（随机）、volatile-ttl、volatile-lru、volatile-lfu`  
    - 对全部数据进行淘汰：`allkeys-random（随机）、allkeys-lru、allkeys-lfu`



## 5.数据库与缓存一致性

**缓存更新常用策略（策略）有四种：**

1. Cache aside：
   1. **失效**：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。
   2. **命中**：应用程序从cache中取数据，取到后返回。
   3. **更新**：先把数据存到数据库中，成功后，再让缓存失效。
2. Read through：将 **缓存和持久化看成一个整体**，读取时失效再由缓存服务持久化与更新缓存
3. Write through：将 **缓存和持久化看成一个整体**，更新时没有命中缓存则直接由缓存服务更新数据库数据；更新时命中则先更新缓存再更新数据库
4. Write behind caching（Write back）：在更新数据时只更新缓存而不更新数据库，之后缓存会异步批量更新数据库，这样 I/O 会很快并且持久化操作可以合并，缺点就是数据不是强一致性的且可能会丢失（主机断电等原因）

**队列 + 重试机制：** 会入侵业务代码

- 更新数据库数据；
- 缓存因为种种问题删除失败
- 将需要删除的key发送至消息队列
- 自己消费消息，获得需要删除的key
- 继续重试删除操作，直到成功

**异步更新缓存（基于订阅binlog的同步机制）：**

- 更新数据库数据
- 更新操作写入 binlog 并由非业务代码进行提取
- 将需要删除的key发送至消息队列
- 非业务代码消费消息
- 继续重试删除操作，直到成功