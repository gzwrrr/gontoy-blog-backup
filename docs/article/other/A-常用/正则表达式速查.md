---
# notPage: true
---



# 正则表达式速查

:::info
本文档出自 Codesheep 羊哥，这里只是为了方便就直接把 PDF 放上来了  
[羊哥 B 站主页戳这里](https://space.bilibili.com/384068749?spm_id_from=333.337.0.0)，另外，极力推荐羊哥的网站：[r2coding 编程自学之路](https://r2coding.com/)
:::









## 基本知识






::: tabs#fruit


@tab:active 字符

| **表达式** | **描述**                                               |
| ---------- | ------------------------------------------------------ |
| `[abc]`    | 字符集。匹配集合中所含的任一字符。                     |
| `[^abc]`   | 否定字符集。匹配任何不在集合中的字符。                 |
| `[a-z]`    | 字符范围。匹配指定范围内的任意字符。                   |
| `.`        | 匹配除换行符以外的任何单个字符。                       |
| `\`        | 转义字符。                                             |
| `\w`       | 匹配任何字母数字，包括下划线（等价于`[A-Za-z0-9_]`）。 |
| `\W`       | 匹配任何非字母数字（等价于`[^A-Za-z0-9_]`）。          |
| `\d`       | 数字。匹配任何数字。                                   |
| `\D`       | 非数字。匹配任何非数字字符。                           |
| `\s`       | 空白。匹配任何空白字符，包括空格、制表符等。           |
| `\S`       | 非空白。匹配任何非空白字符。                           |

@tab 分组和引用

| **表达式**       | **描述**                                                     |
| ---------------- | ------------------------------------------------------------ |
| `(expression)`   | 分组。匹配括号里的整个表达式。                               |
| `(?:expression)` | 非捕获分组。匹配括号里的整个字符串但不获取匹配结果，拿不到分组引用。 |
| `\num`           | 对前面所匹配分组的引用。比如`(\d)\1`可以匹配两个相同的数字，`(Code)(Sheep)\1\2`则可以匹配`CodeSheepCodeSheep`。 |

@tab 锚点/边界

| **表达式** | **描述**                                                     |
| ---------- | ------------------------------------------------------------ |
| `^`        | 匹配字符串或行开头。                                         |
| `$`        | 匹配字符串或行结尾。                                         |
| `\b`       | 匹配单词边界。比如`Sheep\b`可以匹配`CodeSheep`末尾的`Sheep`，不能匹配`CodeSheepCode`中的`Sheep` |
| `\B`       | 匹配非单词边界。比如`Code\B`可以匹配`HelloCodeSheep`中的`Code`，不能匹配`HelloCode`中的`Code`。 |

@tab 数量

| **表达式** | **描述**                                   |
| ---------- | ------------------------------------------ |
| `?`        | 匹配前面的表达式0个或1个。即表示可选项。   |
| `+`        | 匹配前面的表达式至少1个。                  |
| `*`        | 匹配前面的表达式0个或多个。                |
| `|`        | 或运算符。并集，可以匹配符号前后的表达式。 |
| `{m}`      | 匹配前面的表达式m个。                      |
| `{m,}`     | 匹配前面的表达式最少m个。                  |
| `{m,n}`    | 匹配前面的表达式最少m个，最多n个。         |

@tab 预查断言

| **表达式** | **描述**                                                     |
| ---------- | ------------------------------------------------------------ |
| `(?=)`     | 正向预查。比如`Code(?=Sheep)`能匹配`CodeSheep`中的`Code`，但不能匹配`CodePig`中的`Code`。 |
| `(?!)`     | 正向否定预查。比如`Code(?!Sheep)`不能匹配`CodeSheep`中的`Code`，但能匹配`CodePig`中的`Code`。 |
| `(?<=)`    | 反向预查。比如`(?<=Code)Sheep`能匹配`CodeSheep`中的`Sheep`，但不能匹配`ReadSheep`中的`Sheep`。 |
| `(?<!)`    | 反向否定预查。比如`(?<!Code)Sheep`不能匹配`CodeSheep`中的`Sheep`，但能匹配`ReadSheep`中的`Sheep`。 |

@tab 特殊标志

| **表达式** | **描述**                   |
| ---------- | -------------------------- |
| `/.../i`   | 忽略大小写。               |
| `/.../g`   | 全局匹配。                 |
| `/.../m`   | 多行修饰符。用于多行匹配。 |

:::



<ShowPdf filePath="其他" fileName="正则表达式速查备忘手册" />





## 正则原理





正则引擎主要可以分为基本不同的两大类：

1. DFA (Deterministic finite automaton) 确定型有穷自动机
2. NFA (Non-deterministic finite automaton) 非确定型有穷自动机

**DFA引擎 和 NFA引擎 的区别就在于**：在没有编写正则表达式的前提下，是否能确定字符执行顺序

<br/>

> DFA（是电动机） 和NFA（汽油机） 都有很长的历史，不过，正如汽油机一样，NFA 的历史更长一些。也有些系统采用了混合引擎，它们会根据任务的不同选择合适的引擎（甚至对同一表达式中的不同部分采用不同的引擎，以求得功能与速度之间的最佳平衡）。 ——《精通正则表达式》

DFA引擎的特点：

1. **文本主导**：按照文本的顺序执行，这也就能说明为什么DFA引擎是确定型(deterministic)了，稳定
2. **记录当前有效的所有可能**：我们看到当执行到`(d|b)`时，同时比较表达式中的`d`和`b`，所以会需要更多的内存
3. **每个字符只检查一次**：这提高了执行效率，而且速度与正则表达式无关
4. **不能使用反向引用等功能**：因为每个字符只检查一次，文本零宽度（位置）只记录当前比较值，所以不能使用反向引用、环视等一些功能

<br/>



NFA引擎的一些特点：

1. **文表达式主导**：按照表达式的一部分执行，如果不匹配换其他部分继续匹配，直到表达式匹配完成。
2. **会记录某个位置**：我们看到当执行到`(d|b)`时，NFA引擎会记录字符的位置（零宽度），然后选择其中一个先匹配。
3. **单个字符可能检查多次**：我们看到当执行到`(d|b)`时，比较`d`后发现不匹配，于是NFA引擎换表达式的另一个分支`b`，同时文本位置**回退**，重新匹配字符'b'。这也是NFA引擎是非确定型的原因，同时带来另一个问题效率可能没有DFA引擎高。
4. **可实现反向引用等功能**：因为具有**回退**这一步，所以可以很容易的实现反向引用、环视等一些功能！

绝大多数的变成语言采用的都是 NFA 引擎，NFA引擎的特点是：**功能强大**、但有回溯机制所以**效率慢**

需要特别注意的是：NFA 由于有回溯所以可能出现 **回溯陷阱**，这个严重情况可能会让 CPU 到达 100%





:::note 原文

[原文戳这里](https://zhuanlan.zhihu.com/p/107836267)

:::