---
title: "领域模型分类"
shortTitle: "领域模型分类"
description: "领域模型分类"
icon: ""
author: 
  name: gzw
  url: 
  email: 1627121193@qq.com
isOriginal: false
date: 2022-09-25
category: 
- "架构"
- "通用"
tag:
- "架构"
- "通用"
sticky: 1
star: false
article: true
timeline: true
dir:
  text: "领域模型分类"
  icon: ""
  collapsible: true
  index: true
  comment: true
headerDepth: 3
index: true
order: 2
copy:
  triggerWords: 100
  disableCopy: false
  disableSelection: false
feed:
  title: "领域模型分类"
  description: "领域模型分类"
  author:
    name: gzw
    email: 1627121193@qq.com
---



# 领域模型分类

[[toc]]


# 写在前面

> 以下探讨的不是 DDD 领域驱动设计的内容，而是 MVC 架构中的 Model 一层；虽然概念比较多，一开始可能也比较摸不着头脑（会有疑问：为什么要弄得这么复杂），但是有一定的开发经验后再回过头来理解，就会发现其中的好处，所以这里就先放下疑问，先了解完再思考

**领域模型大致有五类：**

- VO
- DTO
- DO
- BO
- PO

**此外，还有一些关联的概念：**

- Entity
- Domain
- POJO



<br/>

# VO (View Object)

> **门面**：出去见人前要先把自己收拾好，让别人看到想看的；对接**搬运工**，拿到自己想要的东西再收拾自己

- 视图对象
- 用于展示层
- 用于把某个指定页面或者组件的所有数据封装起来
- VO 对象中的数据一般是 DTO 经过一定的业务逻辑转化而来的（值或者字段可能都不一样）

注：还用一种 VO 是指 Value Object，是只有状态而没有行为的对象，相关概念有贫血模型，这里就不展开叙述了



<br/>

# DTO (Data Transfer Object)

> **搬运工**：搬运前要将物品（数据）搬上车整理好；对接**门面**，交付物品

- 数据传输对象
- 原本来源于 J2EE 的设计模式，旨在提供粗粒度的数据实体，减少分布式调用的次数，降低网络负载，提高性能
- 另一层是泛指展示层和服务层之间用于数据传输的对象

**两种存在形式：**

- 前端：DTO 存在形式通常是 JS 中的（JSON） 对象，是通过异步请求获取到的数据对象
- 后端：上述提到的传输对象，不需要考虑前后端对象的转换，使用的框架一般都会解决这个问题



<br/>

# PO (Persistent Object)

> **记录员**：负责把数据原原本本地记录到库中；对接主管，把数据悉数上交

- 持久化对象，与 Entity 实体的概念是一致的
- 跟持久层的数据形成一一对应的映射关系
- 对于现在的开发而言，一般来说 PO 对象就是上文所说的贫血模型（Value Object），行为只有 setter/getter（这里涉及到了 DDD，不展开叙述）
- 对于简单的业务来说，PO 有时也可以充当 DTO



<br/>

# BO (Business Object)

> **主管**：管记录员；对接搬运工，将记录员的全部数据交给搬运工运输

- BO 简单来说就是 PO 的组合
- 如果 PO 是一条数据记录对象，那么 BO 就是全部数据记录的集合对象

- 不难发现 BO 其实就是一个业务对象，BO 中会有很多跟业务有关的行为或操作
- BO 这个概念在许多框架中可能不易察觉，因为这些框架自身就带有数据组合的功能，因此 PO 拼接成 BO 这个操作可能在业务层完成（在实现业务逻辑中完成）；也有可能是在数据访问层由框架直接生成 BO
- BO 与 DTO 的区别主要就是字段数量不同，一般 BO 的字段会比 DTO 多，因为处理业务过程中需要额外的数据，而交到 DTO 手中之后，DTO 就只需要选择自己需要的即可



<br/>

# DO (Domain Object)

> 实际含义比较抽象，就不拟人了

- 领域对象
- 指从现实世界抽象出来的业务实体（这里其实与 DDD 的关联更大，但是并非重点，不赘述）
- 当 DO 的含义为 Data Object 时，其实就等同于上面的 PO（阿里巴巴手册中的定义）
- 当 DO 的含义为 Domain Object 时，其实就等于上面的 BO



<br/>

# POJO (Plain ordinary java object)

> 无规则简单 Java 对象，也叫 Pure old java object，实际上就是普通的 JavaBean

- POJO 其实是一个中间对象，可以转化为上述的 VO/PO/DTO

- 或者换种说法更为直接：POJO 持久化后就是 PO；POJO 在传输过程中就是 DTO；POJO 用作表示层时就是 VO
- 但是在一般的开发中，PO 对象所在的包一般以 pojo 命名（或者使用 entity/domain），而这只是为了区分不同的对象，不必太过纠结



<br/>

# Entity/Domain

> 可以理解成 pojo 的别名，虽然概念和范围上不太相同，但是并不会有影响

- Entity：实体类，属性严格对应数据库表的字段，类似 PO
- Domain：封装了数据库字段的 JavaBean 对象，其中可以封装多个表格数据，范围比较大，类似 BO
- 但是实际开发中，pojo/entity/domain 包下的对象一般都是 PO，这里不必纠结



<br/>

# 写在最后

- 其实有这么多概念只是为了做出**层次划分**和**规范**；划分层次其实是提供了类似防腐层的作用，使得项目结构清晰的同时有着更多的容错性，规范则是让团队协作开发更加容易
- 诚然，如果不考虑项目的实际情况就全部套用，可能会让项目变得复杂繁琐，而实际开发中，确实不会全部套用，更多的是开发小组内讨论决定使用怎么样的规范，最终目的其实是为了项目的**开发效率**和**可维护性**
- 对于这些概念其实也不必太过纠结，更重要的是理解其背后的含义，如何称呼或者划分只是一个表现形式，实际落地要懂得变通，只要形成了组内的规范并且达到了其含义背后想要的结果即可



<br/><br/>