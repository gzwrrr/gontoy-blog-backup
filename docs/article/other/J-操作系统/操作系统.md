---
title: "操作系统"
shortTitle: "操作系统"
description: "操作系统"
icon: ""
author: 
  name: gzw
  url: 
  email: 1627121193@qq.com
isOriginal: false
date: 2022-02-01
category: 
- "操作系统"
tag:
- "操作系统"
sticky: 1
star: true
article: true
timeline: true,
dir:
  text: "操作系统"
  icon: ""
  collapsible: true
  index: true
  comment: true
headerDepth: 3
index: true
order: 2
copy:
  triggerWords: 100
  disableCopy: false
  disableSelection: false
feed:
  title: "操作系统"
  description: "操作系统"
  author:
    name: gzw
    email: 1627121193@qq.com

---





# 操作系统

:::info 参考

[JavaGuide 操作系统常见面试题总结](https://javaguide.cn/cs-basics/operating-system/operating-system-basic-questions-01.html#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8)

:::



## 基础

操作系统的作用：

1. 进程和线程的管理：进程的创建、撤销、阻塞、唤醒，进程间的通信等
2. 文件管理：内存的分配和管理、外存（磁盘等）的分配和管理等
3. 存储管理：文件的读、写、创建及删除等
4. 设备管理：完成设备（输入输出设备和外部存储设备等）的请求或释放，以及设备启动等功能
5. 网络管理：操作系统负责管理计算机网络的使用。网络是计算机系统中连接不同计算机的方式，操作系统需要管理计算机网络的配置、连接、通信和安全等，以提供高效可靠的网络服务
6. 安全管理：用户的身份认证、访问控制、文件加密等，以防止非法用户对系统资源的访问和操作



用户态和内核态：

1. 用户态切换到内核态的方式：
   1. 系统调用：用户程序调用系统接口，例如进程管理、文件管理、存储管理、设备管理。一般过程是发起系统调用 -> trap 中断 -> 内核执行系统调用 -> trap 中断 -> 返回
   2. 中断
   3. 异常





## 进程与线程

**进程（Process）** 是指计算机中正在运行的一个程序实例。举例：你打开的微信就是一个进程。

**线程（Thread）** 也被称为轻量级进程，更加轻量。多个线程可以在同一个进程中同时执行，并且共享进程的资源比如内存空间、文件句柄、网络连接等。举例：你打开的微信里就有一个线程专门用来拉取别人发你的最新的消息。

区别：

1. 线程是进程划分成的更小的运行单位,一个进程在其执行的过程中可以产生多个线程
2. 线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响
3. 线程执行开销小，但不利于资源的管理和保护；而进程正相反

使用线程的好处：

1. 成本低：进程切换是一个开销很大的操作，线程切换的成本较低
2. 轻量：线程更轻量，一个进程可以创建多个线程
3. 高并发：多个线程可以并发处理不同的任务，更有效地利用了多处理器和多核计算机。而进程只能在一个时间干一件事，如果在执行过程中遇到阻塞问题比如 IO 阻塞就会挂起直到结果返回
4. 资源共享：同一进程内的线程共享内存和文件，因此它们之间相互通信无须调用内核

为什么使用线程：

1. 计算机层面：线程切换和调度的开销更小。单核 CPU 下假如一个线程发生阻塞，其他线程也还可以使用 CPU，多核 CPU 下可以实现并行操作，可以减少线程上下文切换的开发
2. 互联网发展趋势：多线程并发编程是高并发的基础，可以提高系统整体的并发能力以及性能

线程同步方式：

1. **互斥锁(Mutex)** ：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 `synchronized` 关键词和各种 `Lock` 都是这种机制。
2. **读写锁（Read-Write Lock）**：允许多个线程同时读取共享资源，但只有一个线程可以对共享资源进行写操作。
3. **信号量(Semaphore)** ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。
4. **屏障（Barrier）** ：屏障是一种同步原语，用于等待多个线程到达某个点再一起继续执行。当一个线程到达屏障时，它会停止执行并等待其他线程到达屏障，直到所有线程都到达屏障后，它们才会一起继续执行。比如 Java 中的 `CyclicBarrier` 是这种机制。
5. **事件(Event)** :Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。





## PCB

1. 进程控制块，OS 用于监控和追踪进程的数据结构，每个进程都对应一个独立的 PCB
2. 创建一个进程是会为进程分配一个唯一 ID 并且创建相应的 PCB，PCB 中的信息在进程运行过程中不断变化，OS 根据这些信息来管理和调度进程





## 进程

进程的状态：

1. NEW 创建状态
2. READY 就绪状态
3. RUNNING 运行状态
4. WAITING 等待状态或者阻塞状态
5. TERMINATED 结束状态

进程通信方式：

1. 管道：匿名管道、有名管道
2. 信号：接收事件
3. 信号量：计数器
4. 消息队列
5. 共享内存
6. 套接字

进程常见的调度算法：

1. 先来先服务
2. 短作业优先
3. 时间片轮转
4. 优先级队列

其他：

1. **僵尸进程** ：子进程已经终止，但是其父进程仍在运行，且父进程没有调用 wait()或 waitpid()等系统调用来获取子进程的状态信息，释放子进程占用的资源，导致子进程的 PCB 依然存在于系统中，但无法被进一步使用。这种情况下，子进程被称为“僵尸进程”。避免僵尸进程的产生，父进程需要及时调用 wait()或 waitpid()系统调用来回收子进程
2. **孤儿进程** ：一个进程的父进程已经终止或者不存在，但是该进程仍在运行。这种情况下，该进程就是孤儿进程。孤儿进程通常是由于父进程意外终止或未及时调用 wait()或 waitpid()等系统调用来回收子进程导致的。为了避免孤儿进程占用系统资源，操作系统会将孤儿进程的父进程设置为 init 进程（进程号为 1），由 init 进程来回收孤儿进程的资源





## 死锁

> 死锁（Deadlock）描述的是这样一种情况：多个进程/线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于进程/线程被无限期地阻塞，因此程序不可能正常终止。

发生死锁的条件：

1. 资源互斥
2. 非抢占调度
3. 占有资源并等待另一资源
4. 循环等待

解决死锁的方法：

1. 预防：限制资源使得上述条件不能成立（例如银行家算法）
2. 避免：分配资源时提前预测
3. 检测：系统有特定的机构能够定位死锁
4. 解除：配合检测机构接触进程的死锁状态