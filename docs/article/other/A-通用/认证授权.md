---
title: "认证授权"
shortTitle: "认证授权"
description: "认证授权"
icon: ""
author: 
  name: gzw
  url: 
  email: 1627121193@qq.com
isOriginal: false
date: 2022-06-15
category: 
- "通用"
- "安全"
tag:
- "通用"
- "安全"
sticky: 1
star: false
article: true
timeline: true
dir:
  text: "认证授权"
  icon: ""
  collapsible: true
  index: true
  comment: true
headerDepth: 3
index: true
order: 2
copy:
  triggerWords: 100
  disableCopy: false
  disableSelection: false
feed:
  title: "认证授权"
  description: "认证授权"
  author:
    name: gzw
    email: 1627121193@qq.com
---

  

# 认证授权

:::info 相关文章

[细说API – 认证、授权和凭证](https://zhuanlan.zhihu.com/p/60522006)

:::



## 认证授权的方式

> 认证：authentication，标识身份，解决 `who are you` 的问题；授权：authorization，授予资源，解决 `what can you do` 的问题，往往需要配合认证来完成。
>
> 注意：不用太过于纠结一个规范是用于认证还是授权（比如 OAuth），因为在一个系统中认证和授权往往是无法被孤立实现的。

大致分为以下几类（有些是有包含关系的，后续可能再做调整）：

1. 基本身份验证（HTTP Basic AUthentication）
2. 公钥登录私钥认证
3. OAuth 开放授权标准
4. 基于令牌的身份验证
5. HMAC（AK/SK）认证
6. 双因素身份验证
7. OTP （One time password ）一次性密码





### 基本身份验证

基本身份验证（HTTP Basic AUthentication）：这是最简单的身份验证形式，需要用户提供用户名和密码才能访问网站。凭据通常以纯文本形式发送，这使得这种方法不太安全。然而，它对于不需要高安全级别的简单网站或内部应用程序很有用。





### 公钥登录私钥认证

SSH (Secure Shell)默认使用公钥认证方式。在公钥认证中，用户生成一个公私密钥对，其中公钥与服务器共享，私钥安全保存在用户的设备上。当用户尝试与服务器进行身份验证时，服务器向用户发送一个挑战，然后用户用他们的私钥对挑战进行签名，并将签名后的挑战发送回服务器。如果服务器可以通过公钥验证签名，则认证通过。

与密码身份验证等其他身份验证方法相比，公钥身份验证提供了增强的安全性，因为它不要求用户与服务器共享密码。它还允许无需用户干预的自动身份验证。

除了公钥身份验证之外，SSH还支持其他身份验证方法，如密码身份验证和基于主机的身份验证。但推荐使用公钥认证，因为它具有更高的安全性和便捷性。

以下是一个简单的例子：

1. **生成密钥对：** 用户首先在本地生成一对密钥，包括一个私钥（私有的，保存在本地）和一个公钥（可以分享给其他人）。

   ```sh
   # 生成密钥对
   ssh-keygen -t rsa
   ```

   在执行上述命令后，系统将生成一个私钥文件（通常为`~/.ssh/id_rsa`）和一个公钥文件（通常为`~/.ssh/id_rsa.pub`）。

2. **将公钥上传到服务器：** 用户将生成的公钥文件上传到远程服务器，通常是通过将公钥内容追加到目标服务器上的`~/.ssh/authorized_keys`文件。

   ```sh
   # 将公钥内容追加到远程服务器的authorized_keys文件
   cat ~/.ssh/id_rsa.pub | ssh user@remote_server "mkdir -p ~/.ssh && cat >> ~/.ssh/authorized_keys"
   ```

3. **登录过程：** 用户使用私钥进行认证，而无需在每次登录时输入密码。

   ```sh
   # 使用私钥登录到远程服务器
   ssh -i ~/.ssh/id_rsa user@remote_server
   ```

在这个例子中，用户生成一对密钥，将公钥上传到服务器，并使用私钥进行登录。私钥保持在本地，不需要在每次登录时输入密码，这提供了更高的安全性。这种机制通常用于SSH（Secure Shell）协议，但类似的原理也可以在其他身份验证和授权场景中使用。







### OAuth 开放授权标准

OAuth: OAuth是一种广泛使用的认证协议，它允许用户将自己在一个网站上的资源授权给另一个网站，而无需共享自己的证书。通常用于**社交登录**，可用于第三方网站的用户认证。

OAuth（开放授权）是一个开放标准，允许用户授权第三方网站访问他们存储在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方网站或分享他们数据的所有内容。

OAuth 是一个授权标准，而不是认证标准。**提供资源的服务器**不需要知道确切的用户身份（session），只需要验证授权服务器授予的权限（token）即可。

OAuth 的基本思路就是通过授权服务器获取 access token 和 refresh token（refresh token 用于重新刷新access token），然后通过 access token 从资源服务器获取数据 。在特定的场景下还有下面几种模式：

1. 授权码模式（authorization code）
2. 简化模式（implicit）
3. 密码模式（resource owner password credentials）
4. 客户端模式（client credentials）

如果需要获取用户的认证信息，OAuth 本身没有定义这部分内容，如果需要识别用户信息，则需要借助另外的认证层，例如 OpenID Connect。

关键的对象：

- 资源服务器
- 授权服务器



以下是一个简单的OAuth流程的例子：

1. **注册应用：** 开发者在服务提供者的开发者平台上注册他们的应用，并获取客户端ID和客户端密钥。例如，在注册一个应用程序来访问GitHub上的用户数据时，你会得到一个GitHub应用的客户端ID和客户端密钥。

2. **获取授权：** 用户访问第三方应用，并选择使用服务提供者的身份进行登录。第三方应用将重定向用户到服务提供者的授权页面，包括客户端ID和请求的权限范围。

3. **用户授权：** 用户在服务提供者的页面上看到应用请求的权限，并可以选择授权或拒绝。如果用户授权，服务提供者将生成一个授权码。

4. **交换授权码：** 第三方应用使用授权码向服务提供者请求访问令牌。此请求还包括客户端ID和客户端密钥。请求示例：

   ```sh
   POST /token HTTP/1.1
   Host: oauth-provider.com
   Content-Type: application/x-www-form-urlencoded
   
   client_id=CLIENT_ID&client_secret=CLIENT_SECRET&code=AUTHORIZATION_CODE&grant_type=authorization_code&redirect_uri=REDIRECT_URI
   ```

5. **获得访问令牌：** 服务提供者验证授权码和客户端凭证，并返回访问令牌。

   ```sh
   {
     "access_token": "ACCESS_TOKEN",
     "token_type": "bearer",
     "expires_in": 3600,
     "refresh_token": "REFRESH_TOKEN"
   }
   ```

6. **使用访问令牌：** 第三方应用使用访问令牌向服务提供者的受保护资源请求数据。请求示例：

   ```sh
   GET /api/userinfo HTTP/1.1
   Host: api.provider.com
   Authorization: Bearer ACCESS_TOKEN
   ```

这就是OAuth的基本流程。它允许用户授权第三方应用程序，而无需共享他们的凭证，提高了安全性。



OAuth 与 OAuth2

1. **版本差异：**
   - OAuth是1.0版本，最初发布于2007年。
   - OAuth 2.0 是OAuth的下一代，于2012年发布。
2. **认证方式：**
   - OAuth 1.0 使用签名方法进行认证，要求请求方使用访问令牌和共享密钥生成签名，这需要一些复杂的逻辑。
   - OAuth 2.0 引入了更简化的流程，通过直接传递令牌来进行认证，省略了复杂的签名步骤。
3. **扩展性：**
   - OAuth 1.0 难以扩展，引入新特性相对复杂。
   - OAuth 2.0 更具扩展性，支持通过插件添加新的认证和授权流程。
4. **授权流程：**
   - OAuth 1.0 主要支持三种授权流程：授权码流（Authorization Code）、隐式流（Implicit Grant）、客户端凭证流（Client Credentials Grant）。
   - OAuth 2.0 引入了更多的授权流程，包括授权码流、隐式流、密码凭证流（Resource Owner Password Credentials Grant）、客户端凭证流、刷新令牌流（Refresh Token Grant）等。
5. **安全性：**
   - OAuth 1.0 的签名机制提供了一定的安全性，但实现和使用起来相对复杂。
   - OAuth 2.0 引入了更简单、更通用的访问令牌机制，但要求实现时采取适当的安全措施，如使用HTTPS来防止令牌被窃取。
6. **状态管理：**
   - OAuth 1.0 要求客户端和服务提供者都必须维护请求和令牌之间的状态。
   - OAuth 2.0 为客户端和服务提供者之间的状态管理提供了更大的灵活性，允许无状态的令牌请求。





### JWT

用户提供令牌，如JWT (JSON Web令牌)，然后由服务器验证该令牌以验证用户。这种方法比基本身份验证更安全，因为令牌通常是加密的，必要时可以撤销。

在 OAuth 等分布式的认证、授权体系下，对凭证技术有了更多的要求，比如包含用户 ID、过期等信息，不需要再外部存储中关联。因此业界对 token 做了进一步优化，设计了一种自包含令牌，令牌签发后无需从服务器存储中检查是否合法，通过**解析令牌**就能获取令牌的过期、有效等信息，这就是JWT （JSON Web Token）。

JWT 是一种包含令牌（self-contained token），或者叫值令牌 （value token），我们以前使用关联到 session 上的 hash 值被叫做引用令牌（reference token）。

只需要签名的 secret key 就能校验 JWT 令牌，如果在消息体中加入用户 ID、过期信息就可以实现验证令牌是否有效、过期了，无需从数据库/缓存中读取信息。因为使用了加密算法，所以第一、二部分即使被修改（包括过期信息）也无法通过验证。JWT 优点是不仅可以作为 token 使用，同时也可以承载一些必要信息，省去多次查询。

1. JWT token 的第一、二部分只是 base64 编码，肉眼不可读，不应当存放敏感信息
2. JWT token 的自包含特性，导致了无法被撤回
3. JWT 的签名算法可以自己拟定，为了便于调试，本地环境可以使用对称加密算法，生产环境建议使用非对称加密算法

当然 OAuth 对 access token 等凭证所选用的技术并没有做出限制，OAuth 并不强制使用 JWT，在使用 JWT 自包含特性的优势时，必须考虑到 JWT 撤回困难的问题。在一些对撤回 token 要求很高的项目中不适合使用JWT，即使采用了一些方案实现（whitelist 和 blacklist）也违背了设计 JWT 的初衷。





### HMAC（AK/SK）认证

:::info 相关文章

[HMAC 算法及其应用](https://zhuanlan.zhihu.com/p/136590049)

:::

HMAC（AK/SK）认证：在我们对接一些 PAAS 平台和支付平台时，会要求我们预先生成一个 access key（AK） 和 secure key（SK），然后通过签名的方式完成认证请求，这种方式可以避免传输 secure key，且大多数情况下签名只允许使用一次，避免了重放攻击。

这种基于 AK/SK 的认证方式主要是利用散列的消息认证码 (Hash-based Message Authentication Code) 来实现的，因此有很多地方叫 HMAC 认证，实际上不是非常准确。HMAC 只是利用带有 key 值的哈希算法生成消息摘要，在设计 API 时有具体不同的实现。

HMAC 在作为网络通信的认证设计中作为凭证生成算法使用，避免了口令等敏感信息在网络中传输。基本过程如下：

1. 客户端需要在认证服务器中预先设置 access key（AK 或叫 app ID） 和 secure key（SK）
2. 在调用 API 时，客户端需要对参数和 access key 进行自然排序后并使用 secure key 进行签名生成一个额外的参数 digest
3. 服务器根据预先设置的 secure key 进行同样的摘要计算，并要求结果完全一致
4. **注意 secure key 不能在网络中传输，以及在不受信任的位置存放（浏览器等）**

为了让每一次请求的签名变得独一无二，从而实现重放攻击，我们需要在签名时放入一些干扰信息。

在业界标准中有两种典型的做法：

1. 质疑/应答算法（OCRA: OATH Challenge-Response Algorithm）
2. 基于时间的一次性密码算法（TOTP: Time-based One-time Password Algorithm）

例子：OSS对象对象存储调用





### OpenId


OpenID 是一个开放的、分布式的身份验证协议，它并不是构建在特定的技术或协议之上，而是依赖于一系列互操作的规范。OpenID 主要基于以下关键元素：

1. **URLs（统一资源定位符）：** OpenID 使用URLs作为唯一的用户标识。用户的 OpenID 是一个URL，通常是他们选择的 OpenID 提供者的标识。例如，一个用户的 OpenID 可能是类似于`https://openid-provider.com/user123`的URL。
2. **HTTP 协议：** OpenID 的通信主要基于 HTTP 协议。用户在登录时，通过浏览器与 OpenID 提供者进行 HTTP 交互，以进行身份验证和令牌传递。
3. **标识令牌：** OpenID 使用标识令牌来传递身份信息。用户在 OpenID 提供者身份验证成功后，将获得一个包含有关其身份的令牌，该令牌以安全的方式传递回使用 OpenID 登录的应用或网站。
4. **OpenID 协议规范：** OpenID 不仅是一个协议，还有一系列的规范和标准，定义了身份验证和令牌传递的详细过程。这包括 OpenID Authentication（身份验证）和 OpenID Connect（建立在 OAuth 2.0 之上的身份层）等规范。



当用户使用 OpenID 登录到某个网站或应用时，他们通常会选择一个提供 OpenID 服务的身份提供者，并使用该提供者的身份信息进行身份验证。以下是一个简单的 OpenID 使用示例：

1. **用户选择 OpenID 提供者：** 用户访问某个网站或应用，选择使用 OpenID 登录。在登录界面上，他们看到一个选项，可以选择他们喜欢的 OpenID 提供者，比如 Google、Facebook 或 GitHub。
2. **重定向到 OpenID 提供者：** 用户选择了他们喜欢的 OpenID 提供者后，网站或应用将重定向用户到选择的 OpenID 提供者的登录页面。用户在该页面上输入其提供者的凭证信息（通常是用户名和密码）。
3. **授权并生成标识令牌：** 用户成功登录并同意将其身份信息提供给网站或应用后，OpenID 提供者生成一个标识令牌，并将用户重定向回最初的网站或应用。此令牌包含有关用户身份的信息。
4. **网站或应用验证令牌：** 网站或应用收到用户的标识令牌后，会通过与 OpenID 提供者进行通信来验证令牌的真实性和有效性。这通常涉及到使用 OpenID 提供者颁发的密钥进行签名验证。
5. **用户登录成功：** 如果令牌验证成功，网站或应用将用户视为已成功登录，并可能创建一个本地帐户，或者直接使用 OpenID 提供者返回的用户信息。





### 双因素身份验证

双因素身份验证:这种方法要求用户提供两种形式的身份验证，如密码和发送到他们手机的代码，以验证自己。这种方法比基本身份验证更安全，可以为处理敏感数据的网站增加额外的安全层。

双因子认证一般是用户名密码再加一种其他方式的认证，如：短信验证、微信或者QQ授权验证、USB令牌、OTP 令牌等等。例子：阿里云登录控制台需要使用密码 + 虚拟 MFA 进行登录。





### OTP 一次性密码

OTP （One time password ）：一次性密码，例如注册邮件和短信中的认证码





## 权限控制模型

大致可以分为：

1. UGO（Linux 权限控制）：User、Group、Other 粗粒度控制
2. ACL：基于用户的访问控制
3. RBAC：基于角色的访问控制
4. ABAC：基于属性的访问控制
5. NGAC：比 ABAC 更细粒度



## 场景

用户网站登录一般有：

- 用户密码登录
- 短信一次性登录
- 双重身份验证登录
- 基于Token或者Session的登录（可能会用JWT）

授权认证：

- Github授权认证（授权服务器/资源服务器，OAuth2）

- OSS对象存储（HAMC AK/SK，接口调用）
- OpenAI登录（openid，可以选择不同的三方授权）



基于令牌的访问：

1. **JWT（JSON Web Token）认证：**用户登录后，系统颁发一个 JSON Web Token，包含了用户的身份信息和一些元数据。客户端将该令牌存储并在每个后续请求中发送给服务器，服务器验证令牌的签名以确保其有效性。
2. **OAuth 2.0 中的令牌认证：**OAuth 2.0 使用访问令牌来授权第三方应用访问资源服务器上受保护的资源。这可以是基于密码的认证（Resource Owner Password Credentials Grant），也可以是基于授权码的认证（Authorization Code Grant）等。
3. **Bearer Token（承载令牌）认证：**在 HTTP 请求的 Authorization 头中使用 Bearer Token，这是一种简单的基于令牌的认证方式。Bearer Token 通常用于 OAuth 2.0 的实现。
4. **Session Token 认证：**用户登录后，系统为其生成一个会话令牌，将该令牌存储在客户端。客户端在每个请求中通过发送该令牌来进行身份验证。
5. **API 密钥认证：**客户端在请求中携带一个 API 密钥，服务器使用该密钥进行身份验证。这通常用于对公共 API 进行访问控制。



## 单点登录

单点登录（Single Sign-On，简称SSO）是一种身份验证机制，允许用户通过一次登录获得对多个关联但独立的软件系统或应用的访问权限，而无需在每个系统中单独进行身份验证。这意味着用户只需要提供一组凭据（通常是用户名和密码）就可以访问多个系统，提高了用户体验的同时也简化了管理和维护工作。

与单点登录相关的一些概念包括：

1. **单点注销（Single Sign-Out）：**单点注销是指用户在一个系统中注销后，其他关联的系统也会自动注销。这有助于确保用户在整个环境中的身份状态保持一致。
2. **身份提供者（Identity Provider，IdP）：**身份提供者是负责验证用户身份并颁发令牌的服务。在SSO中，用户只需登录一次并通过身份提供者验证，然后可以访问与身份提供者关联的所有服务。
3. **服务提供者（Service Provider，SP）：**服务提供者是依赖于单点登录的服务或应用程序。它们依赖于身份提供者颁发的令牌来验证用户身份。
4. **令牌（Token）：**令牌是一种用于在不同系统之间传递身份信息的机制。在SSO中，用户登录后，身份提供者颁发令牌，用户可以在与身份提供者关联的各个服务之间传递该令牌，而不需要再次提供凭据。
5. **Federation（联邦身份验证）：**联邦身份验证是一种扩展的单点登录概念，涉及到在不同的组织之间共享身份验证信息。不同组织的身份提供者和服务提供者可以建立信任关系，允许用户在这些组织之间无缝访问资源。
6. **SSO协议：**SSO的实现通常使用特定的协议，例如SAML（Security Assertion Markup Language）、OAuth（Open Authorization）和OpenID Connect等。





## 其他

还有一个重要的概念是访问控制策略（AC）。如果我们需要把资源的权限划分到一个很细的粒度，就不得不考虑用户以何种身份来访问受限的资源，选择基于访问控制列表（ACL）还是基于用户角色的访问控制（RBAC）或者其他访问控制策略。

- SSH 登录的密匙
- JWT 令牌
- 一次性密码等
- HAMC
- OAuth2
- 凭证技术 JWT

- Open ID、OpenID Connect

- Token in Cookie、Session Token

其他：

- **LDAP（Lightweight Directory Access Protocol）：**用于在目录服务中验证用户身份的协议。
- **SAML（Security Assertion Markup Language）：**用于在身份提供者和服务提供者之间传递身份和认证信息的 XML 标准。
- **Kerberos：**网络身份验证协议，用于通过密钥分发的方式进行身份验证。
- **Biometric Authentication：**利用生物特征，如指纹或面部识别，进行身份验证。





随着微服务的发展，API 的设计不仅仅是面向 WEB 或者 Mobile APP，还有BFF（Backend for Frontend）和 Domain API 的认证，以及第三方服务的集成。

客户端到服务器之间认证和服务器到服务器之间认证是不同的。

我们把终端用户（Human）参与的通信，叫做 Human-to-machine (H2M)，服务器与服务器之间的通信叫做 Machine-to-machine (M2M)。

**另外值得一提的是，H2M 这种通信方式下，客户端不受控制，由于无法自主分发密匙，认证通信的安全高度依赖 HTTPS。**





对于云平台资源和服务的安全访问授权，除了访问密钥和安全密钥认证外，还有多种备选方案。其中一些替代方案包括:

OAuth: OAuth是一种开放的授权标准，允许用户授权第三方应用程序访问他们的资源，而无需共享他们的密码。它通常用于提供对基于云的服务的安全访问，如社交媒体平台和api。

OpenID Connect: OpenID Connect是建立在OAuth 2.0之上的身份验证协议，提供用户身份验证和授权。它允许用户使用单一身份提供者进行身份验证，然后可以使用该身份提供者访问多个服务。

JSON Web Tokens (JWT): JWT是一种紧凑的、url安全的方法，用于表示要在双方之间转移的声明。它通常用于RESTful web服务和单页应用程序中的身份验证和授权。

SAML(安全断言标记语言):SAML是一种基于xml的标准，用于在各方之间交换身份验证和授权数据，特别是在身份提供者和服务提供者之间。它通常用于基于web的单点登录(SSO)，并被基于云的服务广泛支持。

AWS IAM (Identity and Access Management): AWS IAM是一个web服务，可以让您安全地管理对AWS服务和资源的访问。它为AWS服务提供用户身份验证、访问控制和授权等功能。

这些只是用于授权对云平台资源和服务的安全访问的访问密钥和安全密钥认证的替代方案的几个例子。身份验证和授权方法的选择将取决于应用程序或服务的特定需求和用例。



 

公钥和私钥认证与使用访问密钥和安全密钥进行令牌访问认证没有直接关系。

公钥和私钥认证是一种单独的认证方法，它使用一对密钥(一个公钥和一个私钥)在双方之间建立信任。这种方法通常用于客户端和服务器之间的安全通信，其中与服务器共享公钥，而私钥安全地保存在客户端设备上。

另一方面，使用访问密钥和安全密钥的令牌访问身份验证是另一种身份验证方法，它使用使用加密密钥签名和加密的令牌在客户端和服务器之间建立信任。这种方法常用于云平台中授权资源和服务的安全访问。

虽然这两种方法都使用加密密钥，但它们有不同的目的和用例。公私钥认证用于客户端与服务器之间的安全通信，令牌接入认证用于接入密钥和安全密钥对云平台资源和服务的安全访问。





在Java生态系统中，有一些可用的工具和框架来解决网站身份验证的问题，例如:

Spring Security:它是一个广泛使用的基于java的应用程序安全框架，提供身份验证和授权服务。Spring Security支持各种身份验证方法，包括基本身份验证、基于令牌的身份验证和OAuth。

Apache Shiro:这是另一个为Java应用程序提供身份验证、授权和加密服务的安全框架。Apache Shiro支持各种身份验证方法，包括基本身份验证、基于令牌的身份验证和OAuth。

JAAS (Java身份验证和授权服务):它是一个为Java应用程序提供身份验证和授权服务的Java框架。JAAS支持各种身份验证方法，包括基本身份验证、基于令牌的身份验证和双因素身份验证。

根据特定的需求和用例，可以使用这些框架和工具在基于java的web应用程序中实现各种身份验证方法。





访问密钥和安全密钥并不是特定的身份验证方法，而是在基于令牌的身份验证系统(如Amazon Web Services (AWS)和其他云平台)中常用的访问凭证。

在基于令牌的身份验证中，用户提供令牌，如JSON Web令牌(JWT)，用于对用户进行身份验证。令牌通常包含用户的访问密钥和安全密钥，用于签名和验证令牌。访问密钥和安全密钥用于为令牌生成加密签名，然后由服务器验证该签名以验证用户身份。

因此，访问密钥和安全密钥不是独立的身份验证方法，而是基于令牌的身份验证方法的一部分。它们用于提供对AWS等云平台中资源和服务的安全访问。





使用访问密钥和安全密钥进行基于令牌的身份验证是一种常用的方法，因为它有以下几个优点。

增强安全性:使用访问密钥和安全密钥的基于令牌的身份验证提供了增强的安全性，因为令牌通常使用加密密钥进行加密和签名。这有助于防止资源和服务被未经授权的访问，降低中间人攻击、跨站脚本攻击等攻击的风险。

可扩展性:使用访问密钥和安全密钥的令牌身份验证具有高度可扩展性，因为它不需要服务器维护会话状态。这意味着服务器可以处理大量并发请求，而不会使系统过载。

简化开发:使用访问密钥和安全密钥的基于令牌的身份验证可以简化开发，因为它允许开发人员将身份验证逻辑与应用程序逻辑分离。这使得开发和维护复杂的应用程序更加容易。

关于访问密钥和安全密钥的使用，访问密钥通常用于标识请求访问资源或服务的用户或应用程序，而安全密钥用于签名令牌并提供身份验证。通过同时使用访问密钥和安全密钥，服务器可以验证请求是否来自有效的用户或应用程序，并且令牌没有被篡改。

使用访问密钥和安全密钥的基于令牌的身份验证的替代方案包括其他身份验证方法，如基本身份验证、OAuth和双因素身份验证。然而，这些方法都有各自的优缺点，认证方法的选择取决于应用程序的特定需求和用例。









对于云平台资源和服务的安全访问授权，除了访问密钥和安全密钥认证外，还有多种备选方案。其中一些替代方案包括:

OAuth: OAuth是一种开放的授权标准，允许用户授权第三方应用程序访问他们的资源，而无需共享他们的密码。它通常用于提供对基于云的服务的安全访问，如社交媒体平台和api。

OpenID Connect: OpenID Connect是建立在OAuth 2.0之上的身份验证协议，提供用户身份验证和授权。它允许用户使用单一身份提供者进行身份验证，然后可以使用该身份提供者访问多个服务。

JSON Web Tokens (JWT): JWT是一种紧凑的、url安全的方法，用于表示要在双方之间转移的声明。它通常用于RESTful web服务和单页应用程序中的身份验证和授权。

SAML(安全断言标记语言):SAML是一种基于xml的标准，用于在各方之间交换身份验证和授权数据，特别是在身份提供者和服务提供者之间。它通常用于基于web的单点登录(SSO)，并被基于云的服务广泛支持。

AWS IAM (Identity and Access Management): AWS IAM是一个web服务，可以让您安全地管理对AWS服务和资源的访问。它为AWS服务提供用户身份验证、访问控制和授权等功能。

这些只是用于授权对云平台资源和服务的安全访问的访问密钥和安全密钥认证的替代方案的几个例子。身份验证和授权方法的选择将取决于应用程序或服务的特定需求和用例。























