---
title: "设计模式--结构型(7)"
shortTitle: "B-设计模式--结构型(7)"
description: "设计模式--结构型(7)"
icon: ""
author: 
  name: gzw
  url: 
  email: 1627121193@qq.com
isOriginal: false
date: 2022-02-02
category: 
- "设计模式"
tag:
- "设计模式"
sticky: 100
star: true
article: true
timeline: true
dir:
  text: "设计模式--结构型(7)"
  icon: ""
  collapsible: true
  index: true
  comment: true
headerDepth: 3
index: true
order: 2
copy:
  triggerWords: 100
  disableCopy: false
  disableSelection: false
feed:
  title: "设计模式--结构型(7)"
  description: "设计模式--结构型(7)"
  author:
    name: gzw
    email: 1627121193@qq.com
---





# 设计模式--结构型(7)



[[toc]]



## 1.适配器模式

- 将一个类的接口转换成另一种接口，让原本接口不兼容的类可以兼容

- 从用户的角度看不到「被适配者 」，是解耦的

- 用户调用适配器转化出来的目标i接口方法，适配器再调用「被适配者」的相关接口方法 

- 将一个类中的方法通过适配器进行一定的转换

- 分类：
  - 类适配器：使用继承的方式
  - 对象适配器：使用聚合的方式，体现了「合成复用原则」
  - 接口适配器：使用抽象类实现不同的接口的全部方法，只不过这些方法都是空方法，这样在真正使用的时候就可以单独重写一个方法（匿名类重写方法）并只使用该方法



<br/>

## 2.桥接模式

- 结构型设计模式

- 将「实现」和「抽象」放在两个不同的类层次中，使得两个层次可以「独立改变」

- 基于类的「最下设计原则」，通过使用「封装」、「聚合」和「继承」等行为让不同的类承担不同的职责

- 最主要的特点是把「抽象」与「行为实现」分离开来，从而可以保持各个部分的「独立性」以及应对他们的「功能扩展」



<br/>

## 3.装饰器模式

- 装饰器模式就像打包一个快递，主体是被修饰者，填充/纸板等的就为修饰物

- 动态地将新功能「附加」到对象上。在对象的扩展方面，他比继承更有「弹性」，装饰者模式也体现了开闭原则

- 装饰器中可以包含被装饰者，相当于把饮料往调料里边加，而不是把调料往饮料中加



<br/>

## 4.组合模式

- 结构型型模式

- 又称「部分整体模式」，它创建了对象组的树形结构，将对象组合成树状结构以表示「整体-部分」的关系

- 依据树形结构来组合对象，用来表示部分以及整体层次

- 使得用户对单个对象和组合对象的访问具有「一致性」，即组合能让客户以一致的方式处理个别对象以及组合对象



<br/>

## 5.外观模式

- 又称「过程模式」，位子系统中的「一组接口」提供一个「一致的界面」，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用

- 外观模式通过定义一个一致的接口，用以屏蔽内部子系统的细节，使得调用端只需要跟这个接口发生调用，而无需关心这个子系统的内部细节



<br/>

## 6.享元模式

1. 又称「蝇量模式」，运用共享技术有效地支持大量「细粒度」的对象
2. 常用于系统的底层开发，解决系统性能问题。例如数据库连接池里边都是创建好的连接对象，在这些连接对象中我们需要的则直接拿来用，避免了重复创建，如果没有需要的则再创建一个
3. 能够解决重复对象的内存浪费问题，当系统中有大量相似的对象，需要缓冲池时，不需要总是创建新的对象，可以从缓存池中拿，这样可以降低系统内存，同时提高效率
4. 经典的应用场景就是「池」技术，String 常量池/数据库连接池/缓存池等都是享元模式的应用，这是「池」技术的重要实现方式



<br/>

## 7.代理模式

1. 为一个对象提供一个替身，以控制对这个对象的访问
2. 通过代理模式访问目标对象的好处是，可与在目标对象实现的基础上，增加「额外的功能操作」，即扩展目标对象的功能
3. 被代理的对象可以是「远程对象」，「创建开销打大」的对象，「需要安全控制」的对象
4. 代理模式有三种不同的形式：
   - 静态代理
     - 需要定义接口或父类，被代理对象与代理对象一起实现相同的接口或者是继承相同的父类
     - 能够在不修改目标对象功能的情况下，对目标功能进行扩展
   - 动态代理（JDK 代理/接口代理，主要是使用「反射」）
     - 代理对象不需要实现接口，但是目标对象需要实现接口，否则不能用动态代理
     - 代理对象的生成是利用 JDK 的 API，动态地在内存中构建代理对象
   - Cglib 代理（可以在内存中动态地创建对象，而不需要实现接口，属于动态代理的范畴）
     - 又称子类代理，当目标对象只有一个单独的对象的时候，没有任何的接口，这个时候就可以用目标对象子类来实现代理
     - 它是在内存中构建一个子类对象从而实现对目标对象功能扩展
     - Cglib 是一个强大的高性能的代码生成包，它可以在运行期间扩展 Java 类与实现 Java 接口，它广泛地被许多 AOP 框架使用，实现方法拦截
     - 在 AOP 编程中的两种代理：
       - 目标对象需要实现接口，用 JDK 代理
       - 目标对象不需要实现接口，用 Cglib 代理
     - Cglib 包的底层是通过使用字节码处理框架 ASM 来转换字节码并生成新的类

5. 代理模式的变体：
   - 防火墙代理：内网通过代理穿透防火墙，实现对公网的访问
   - 缓存代理：例如：当请求图片文件等资源时，先到缓存代理取，如果取不到资源再到公网或者数据库取，之后再缓存
   - 远程代理：远程对象的本地代表，通过它可以把远程对象当成本地对象来调用。远程代理通过网络和真正的远程对象沟通信息
   - 同步代理：主要使用在多线程编程中，完成多线程间的同步工作

